# 4장 분산 메시지 큐
### 메시지 큐 이점
 * 결합도 완화 : 컴포넌트 사이 강한 결합이 사라진다.
 * 규모 확장성 개선 : 생산자와 소비자를 필요에 맞게 독립적으로 늘릴 수 있다.
 * 가용성 개선 : 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트 활용 가능
 * 성능 개선 : 비동기 통신 활용 가능

### 메시지 큐와 이벤트 스트리밍 플랫폼 차이
 * 이벤트 스트리밍 플랫폼 : 카프카, 펄사
 * 메시지 큐 : rabbitmq, activemq, rocketmq 등
 * 이 둘은 지원 기능이 점차 수렴하면서 차이가 희미해지는 중
 * 전형적인 메시지 큐는 통상적으로 데이터 장기 보관이나 반복 소비 등의 부가 기능을 제공하지 않는다.

## 1단계: 문제 이해 및 설계 범위 확정
### 기능 요구사항
 * 생산자, 소비자 기능
 * 메시지 반복 수신 가능
 * 오래된 이력 데이터 삭제 가능
 * 메시지 크기는 KB 수준
 * 메시지는 생산 순더대로 소비자에게 전달
 * 메시지 전달 방식은 최소 1번, 최대 1번 설정 가능해야

### 비기능 요구사항
 * 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정
 * 규모 확장성
 * 지속성 및 내구성 : 데이터는 디스크에 지속적으로 보관되어야 하며 여러 노드에 복제 필요

### 전통적 메시지 큐와 다른 점
 * 전통적 메시지 큐는 메시지 보관 문제를 다루지 안흔ㄴ다.

## 2단계: 개략적 설계안 제시 및 동의 구하기
### 메시지 모델
#### 일대일 모델
 * 오직 한 소비자만 메시지를 가져갈 수 있다.
 * 전통적 메시지 큐 모델
 * 소비자 수신을 큐에 알리면 메시지는 삭제된다.

#### 발행-구독 모델
 * 메시지를 토픽이라는 주제별로 정리할 수 있다.
 * 해당 토픽을 구독하는 모든 소비자에게 전달 가능하다.

### 토픽, 파티션, 브로커
Q) 토픽에 보관되는 데이터의 양이 커져서 서버 한대로 감당하기 힘든 상황이라면?
 * 파티션, 즉 샤딩을 활용한다.
 * 토픽을 여러 파티션으로 분할한 다음에 메시지를 모든 파티션에 균등하게 나눠 보낸다.
 * 파티션은 메시지 큐 클러스터 내의 서버(브로커)들에 고르게 분산 배치한다.
 * 같은 파티션 안에서는 메시지 순서가 유지된다.
   * 메시지에 사용자 id 를 키로 붙일 수 있는데, 같은 키를 가진 모든 메시지는 같은 파티션으로 보내진다.
 * 토픽을 구독하는 소비자는 하나 이상의 파티션에서 데이터를 가져온다.

### 소비자 그룹
 * 소비자 그룹 내 소비자들은 토픽에서 메시지를 모두 소비하기 위해 협력한다.
 * 하나의 소비자 그룹은 여러 토픽을 구독하고, 오프셋을 별도로 관리한다.
 * 같은 그룹의 소비자는 메시지를 병렬로 소비한다.
 * 병렬로 소비해도 메시지 순서에 문제가 없게 하기 위해, 한 파티션의 메시지는 한 그룹에서 오직 한 소비자만 읽을 수 있도록 한다.
   * 단, 그룹 내 소비자 수가 구독하는 파티션 수보다 크면 어떤 소비자는 놀게 된다.

### 조정 서비스
 * 서비스 탐색 : 어떤 브로커가 살아있는지 체크
 * 리더 선출 : 브로커 가운데 하나는 컨트롤러 역할을 담당해야 한다. 컨트롤러는 파티션 배치를 담당한다.


## 3단계: 상세 설계

### 데이터 저장소
#### 메시지 큐 트래픽 패턴
 * 읽기, 쓰기 모두 빈번
 * 갱신/삭제 연산은 거의 없다.
 * 순차적인 읽기/쓰기가 대부분
#### 선택지1: 데이터베이스
 * 읽기, 쓰기 모두 빈번하게 발생하는 상황을 잘 처리는 DB 설계는 어렵다.
#### 선택지2: WAL(Write-Ahead Log)
 * 새로운 항목이 추가되기만 (append-only) 하는 파일이다.
 * 접근 패턴이 순차적일때 디스크는 아주 좋은 성능을 보인다.
 * 읽기/쓰기 모두 순차적 -> 저렴하고 큰 용량인 회전식 디스크 기반 저장장치 활용 가능
 * 파일 크기는 매우 커질 수 있으므로 세그먼트 단위로 나누는 것이 좋다.
   * 활성 세그먼트를 두고 일정 크기에 도달하면 새 활성 세그먼트 파일을 만들어서 새로운 메시지를 수용하자.
   * 오래된 비활성 세그먼트 파일은 일정 시간이 지나면 삭제해버릴 수 있다.
#### 디스크 성능 관련 유의사항
 * 회전식 디스크가 느리다고 알려져 있지만 이는 랜덤 접근 패턴인 경우다.
 * 순차적으로 데이터 접근 패턴을 활용하면 요구사항을 충족할만한 속도가 나온다.
 * 또한 메모리 캐시를 적극 활용하는 것도 가능하다.

### 메시지 자료 구조
 * 메시지 자료 구조는 생산자, 메시지큐, 소비자 사이의 계약이다

### 메시지 키
 * 메시지의 키는 파티셔을 정할 때 사용된다.
 * 키가 없으면 무작위다. (RR일듯?)

### 생산자 측 작업 흐름
 * 생산자가 어떤 파티션에 메시지를 보낼지, 즉 어느 브로커로 보낼지 결정하는 계층을 라우팅 계층이 있다.
 * 파티션을 여러 개 복제해서 사용하는 경우, 리더 파티션으로 보내야 한다.
 * 라우팅 계층을 따로 두면 네트워크 전송 지연이 발생하므로 이를 생산자 내부에 포함시킨다.
 * (카프카에선 이를 파티셔너라고 한다)
 * 전송 메시지를 버퍼 메모리에 보관했다가 일괄 배치 전송하여 대역폭을 높인다.
 * 얼마나 전송할지는 응답속도와 대역폭의 밸런스로 결정해야 한다.
### 소비자 측 작업 흐름
 * Push vs Pull
   * Push: 지연시간이 낮지만 소비자에게 부하가 크며, 생산량을 예측할 수 없으니 항상 충분한 가용량을 준비해야하는 단점이 있다.
   * Pull: 메시지 소비 속도를 소비자가 결정할 수 있다. 일괄 처리에 적합하다. 브로커에 메시지가 없을수도 있다는 단점이 있다. (이를 개선하기 위해 롱폴링 모드 지원)
#### Pull 모델 동작 흐름
<img src="https://github.com/jaehleeee/study-docs/assets/48814463/153825d8-6263-48ec-83da-87e44466334f" width="500"/>

#### Contoller (브로커 중 하나가 하는 역할)
 * 클러스터 내 브로커에서 장애가 발생하면, 장애가 발생한 브로커 리더 파티션을 정상 브로커로 재배분한다.
 * 컨트롤러 역할의 브로커가에서 장애가 발생하면 다른 브로커가 컨트롤러 역할을 한다 (이 분배는 누가하지? 주키퍼?)   
#### Coordinator (브로커 중 하나가 하는 역할)
 * 여러 브로커 중 하나가 코디네이터 역할을 한다.
 * 컨슈머 그룹의 상태를 체크하며, 그룹 내 컨슈머 장애가 발생하면 매칭된 파티션을 정상 동작하는 다른 컨슈머로 매칭해준다. (리밸런싱 동작)
 * 소비자 그룹마다 코디네이터가 다르다.
 * 코디네이터는 소비자 그룹의 리더를 선출하고, 새 리더 소비자는 `파티션 배치 계획`을 만들어 코디네이터에게 전달한다. 이를 코디네이터가 다른 소비자들에게 알린다.
   * (소비자들끼리 통신하지 않는다는 점 주의.)
 
<img src="https://github.com/jaehleeee/study-docs/assets/48814463/a65bb90c-90bb-4acb-b187-dd386ecd365a" width="500"/>

### 소비자 재조정
 * 어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스
 * 코디네이터 브로커가 필요하다. 소비자들로오는 heartbreat를 살펴서 각 소비자의 파티션 오프셋을 관리한다.
 * 해당 그룹 전담 코디네이터는 그룹 이름을 해싱하면 찾을 수 있다.
 * 같은 그룹의 모든 소비자는 같은 코디네이터와 연결된다.
 * 코디
#### 새로운 소비자 합류
<img src="https://github.com/jaehleeee/study-docs/assets/48814463/aeef736f-38d1-43af-99d9-593f8bb4a586" width="500"/>

### 기존 소비자 이탈
<img src="https://github.com/jaehleeee/study-docs/assets/48814463/91fe0afa-6649-4406-ba1b-c19572199ee8" width="500"/>

### 기존 소비자 장애
<img src="https://github.com/jaehleeee/study-docs/assets/48814463/34c9ecec-3f6d-4f4e-b173-37d8d642fbe7" width="500"/>


### 상태 저장소
 * ㅇㅇ

### 메타데이터 저장소
 * 파티션 수, 메시지 보관 기간, 사본 배치 정보 등을 주키퍼에 저장

### 주키퍼
 * 주키퍼는 계층적 키-값 저장소 기능을 제공하는, 분산 시스템에 필수적
 * 활용 : 분선 설정 서비스, 동기화 서비스, 레지스트리 등

### 복제
 * 분산 시스템에서 하드웨어 장애는 흔한 일이므로 높은 가용성 보장을 위해 복제를 활용한다.
 * 생산자는 리더 파티션에게 메시지를 전송하면, 리더는 팔로워 파티션에게 메시지를 복제한다.
 * 사본을 파티션에 어떻게 분산할지 기술하는 것을 `사본 분산 계획(replica distribution plan) 이라고 하는데,
 * 조정 서비스를 통해 리더 브로커를 선출하고, 리더 브로커가 사본 분산 계획을 만들고 메타데이터 저장소에 저장한다.

### 사본 동기화
 * 동기화된 사본 : ISR (In-Sync Replicas)
 * ISR 은 성능과 영속성 사이의 타협점이다.
 * ISR이 k개의 ack를 받았을때, 생산자에게 수신 확인 응답을 보낸다.
   * ACK=ALL : 영속성 위주, ACK=1, ACK=0 : 성능 위주

### 브로커 결함 내성을 위해 고려해볼만한 사항
 * 사본을 같은 노드에 두지 않기
 * 사본을 여러 데이터 센터에 분산하는 것이 안전 (미러링을 활용하여 데이터 센터간 데이터 복사하는 방법이 있음.)

### 파티션
 * 운영상의 이유로 파티션의 수를 조정해야하는 일이 생길 수 있다.
 * 생산자는 브로커와 통신할때 이 사실을 통지 받으며, 소비자는 리밸린싱을 실행시킨다.
 * 새로운 파티션이 생기면, 기본 파티션은 그대로두고, 새로오는 메시지부터 신규 파티션을 활용 가능하다.
 * 파티션이 삭제되면?
   * 새로운 메시지는 다른 파티션에만 보관
   * 삭제될 파티션은 일정 시간 유지하여 해당 파티션의 데이터를 읽는 소비자 배려
   * 유지 기간이 지나면 데이터를 삭제하고 저장 공간을 반환한다.
   * 이때 소비자는 리밸런싱을 실행시킨다.

### 메시지 전송 방식
 * at-most-once
   * 소실되더라도 재전송 없음.
   * 생산자 ack-==0
   * 소비자는 읽기 전에 오프셋부터 갱신 
 * at-least-once
   * 소실없이 ack=1 or ack=all
   * 소비자는 데이터 성공 처리 후 오프셋 갱신
   * 중복 처리 가능성이 있으므로 대응 필요
 * exactly-once
   * 까다로움, 카프카에선 불가능하다

### 고급 기능
#### 메시지 핕터링
 * 소비자가 다 받아서 불필요한 메시지를 버린다면? 불필요한 트래픽임.
 * 브로커가 메시지를 읽어서 필터링? 브로커 성능 저하될 수 있다 (복호화나 역질렬화가 필요하기 때문)
 * 따라서 태그를 활용하여 브로커에서 필터링할 수 있다.
#### 메시지 지연전송 및 예약 전송
 * DLX rabbitmq 같은 스펙
 * 임시 저장소에 뒀다가 시간 지나면 토픽으로 옮김.

## 4단계: 마무리
추가적으로 하면 좋은 이야기
 * 프로토콜
 * 메시지 소비 재시도
 * 이력 데이터 아카이브
