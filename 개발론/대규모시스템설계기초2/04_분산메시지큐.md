# 4장 분산 메시지 큐
### 메시지 큐 이점
 * 결합도 완화 : 컴포넌트 사이 강한 결합이 사라진다.
 * 규모 확장성 개선 : 생산자와 소비자를 필요에 맞게 독립적으로 늘릴 수 있다.
 * 가용성 개선 : 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트 활용 가능
 * 성능 개선 : 비동기 통신 활용 가능

### 메시지 큐와 이벤트 스트리밍 플랫폼 차이
 * 이벤트 스트리밍 플랫폼 : 카프카, 펄사
 * 메시지 큐 : rabbitmq, activemq, rocketmq 등
 * 이 둘은 지원 기능이 점차 수렴하면서 차이가 희미해지는 중
 * 전형적인 메시지 큐는 통상적으로 데이터 장기 보관이나 반복 소비 등의 부가 기능을 제공하지 않는다.

## 1단계: 문제 이해 및 설계 범위 확정
### 기능 요구사항
 * 생산자, 소비자 기능
 * 메시지 반복 수신 가능
 * 오래된 이력 데이터 삭젝 ㅏ능
 * 메시지 크기는 KB 수준
 * 메시지는 생산 순더대로 소비자에게 전달
 * 메시지 전달 방식은 최소 1번, 최대 1번 설정 가능해야

### 비기능 요구사항
 * 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정
 * 규모 확장성
 * 지속성 및 내구성 : 데이터는 디스크에 지속적으로 보관되어야 하며 여러 노드에 복제 필요

### 전통적 메시지 큐와 다른 점
 * 전통적 메시지 큐는 메시지 보관 문제를 다루지 안흔ㄴ다.

## 2단계: 개략적 설계안 제시 및 동의 구하기
### 메시지 모델
#### 일대일 모델
 * 오직 한 소비자만 메시지를 가져갈 수 있다.
 * 전통적 메시지 큐 모델
 * 소비자 수신을 큐에 알리면 메시지는 삭제된다.

#### 발행-구독 모델
 * 메시지를 토픽이라는 주제별로 정리할 수 있다.
 * 해당 토픽을 구독하는 모든 소비자에게 전달 가능하다.

### 토픽, 파티션, 브로커
Q) 토픽에 보관되는 데이터의 양이 커져서 서버 한대로 감당하기 힘든 상황이라면?
 * 파티션, 즉 샤딩을 활용한다.
 * 토픽을 여러 파티션으로 분할한 다음에 메시지를 모든 파티션에 균등하게 나눠 보낸다.
 * 파티션은 메시지 큐 클러스터 내의 서버(브로커)들에 고르게 분산 배치한다.
 * 같은 파티션 안에서는 메시지 순서가 유지된다.
   * 메시지에 사용자 id 를 키로 붙일 수 있는데, 같은 키를 가진 모든 메시지는 같은 파티션으로 보내진다.
 * 토픽을 구독하는 소비자는 하나 이상의 파티션에서 데이터를 가져온다.

### 소비자 그룹
 * 소비자 그룹 내 소비자들은 토픽에서 메시지를 모두 소비하기 위해 협력한다.
 * 하나의 소비자 그룹은 여러 토픽을 구독하고, 오프셋을 별도로 관리한다.
 * 같은 그룹의 소비자는 메시지를 병렬로 소비한다.
 * 병렬로 소비해도 메시지 순서에 문제가 없게 하기 위해, 한 파티션의 메시지는 한 그룹에서 오직 한 소비자만 읽을 수 있도록 한다.
   * 단, 그룹 내 소비자 수가 구독하는 파티션 수보다 크면 어떤 소비자는 놀게 된다.

### 조정 서비스
 * 서비스 탐색 : 어떤 브로커가 살아있는지 체크
 * 리더 선출 : 브로커 가운데 하나는 컨트롤러 역할을 담당해야 한다. 컨트롤러는 파티션 배치를 담당한다.

## 3단계: 상세 설계
### 데이터 저장소

### 메시지 자료 구조


### 일괄 처리


### 생산자 측 작업 흐름


### 소비자 측 작업 흐름


### 소비자 재조정


### 상태 저장소


###


###
###
###

## 4단계:

