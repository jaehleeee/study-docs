# 4장 분산 메시지 큐
### 메시지 큐 이점
 * 결합도 완화 : 컴포넌트 사이 강한 결합이 사라진다.
 * 규모 확장성 개선 : 생산자와 소비자를 필요에 맞게 독립적으로 늘릴 수 있다.
 * 가용성 개선 : 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트 활용 가능
 * 성능 개선 : 비동기 통신 활용 가능

### 메시지 큐와 이벤트 스트리밍 플랫폼 차이
 * 이벤트 스트리밍 플랫폼 : 카프카, 펄사
 * 메시지 큐 : rabbitmq, activemq, rocketmq 등
 * 이 둘은 지원 기능이 점차 수렴하면서 차이가 희미해지는 중
 * 전형적인 메시지 큐는 통상적으로 데이터 장기 보관이나 반복 소비 등의 부가 기능을 제공하지 않는다.

## 1단계: 문제 이해 및 설계 범위 확정
### 기능 요구사항
 * 생산자, 소비자 기능
 * 메시지 반복 수신 가능
 * 오래된 이력 데이터 삭제 가능
 * 메시지 크기는 KB 수준
 * 메시지는 생산 순더대로 소비자에게 전달
 * 메시지 전달 방식은 최소 1번, 최대 1번 설정 가능해야

### 비기능 요구사항
 * 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정
 * 규모 확장성
 * 지속성 및 내구성 : 데이터는 디스크에 지속적으로 보관되어야 하며 여러 노드에 복제 필요

### 전통적 메시지 큐와 다른 점
 * 전통적 메시지 큐는 메시지 보관 문제를 다루지 안흔ㄴ다.

## 2단계: 개략적 설계안 제시 및 동의 구하기
### 메시지 모델
#### 일대일 모델
 * 오직 한 소비자만 메시지를 가져갈 수 있다.
 * 전통적 메시지 큐 모델
 * 소비자 수신을 큐에 알리면 메시지는 삭제된다.

#### 발행-구독 모델
 * 메시지를 토픽이라는 주제별로 정리할 수 있다.
 * 해당 토픽을 구독하는 모든 소비자에게 전달 가능하다.

### 토픽, 파티션, 브로커
Q) 토픽에 보관되는 데이터의 양이 커져서 서버 한대로 감당하기 힘든 상황이라면?
 * 파티션, 즉 샤딩을 활용한다.
 * 토픽을 여러 파티션으로 분할한 다음에 메시지를 모든 파티션에 균등하게 나눠 보낸다.
 * 파티션은 메시지 큐 클러스터 내의 서버(브로커)들에 고르게 분산 배치한다.
 * 같은 파티션 안에서는 메시지 순서가 유지된다.
   * 메시지에 사용자 id 를 키로 붙일 수 있는데, 같은 키를 가진 모든 메시지는 같은 파티션으로 보내진다.
 * 토픽을 구독하는 소비자는 하나 이상의 파티션에서 데이터를 가져온다.

### 소비자 그룹
 * 소비자 그룹 내 소비자들은 토픽에서 메시지를 모두 소비하기 위해 협력한다.
 * 하나의 소비자 그룹은 여러 토픽을 구독하고, 오프셋을 별도로 관리한다.
 * 같은 그룹의 소비자는 메시지를 병렬로 소비한다.
 * 병렬로 소비해도 메시지 순서에 문제가 없게 하기 위해, 한 파티션의 메시지는 한 그룹에서 오직 한 소비자만 읽을 수 있도록 한다.
   * 단, 그룹 내 소비자 수가 구독하는 파티션 수보다 크면 어떤 소비자는 놀게 된다.

### 조정 서비스
 * 서비스 탐색 : 어떤 브로커가 살아있는지 체크
 * 리더 선출 : 브로커 가운데 하나는 컨트롤러 역할을 담당해야 한다. 컨트롤러는 파티션 배치를 담당한다.


## 3단계: 상세 설계
### 데이터 저장소
#### 메시지 큐 트래픽 패턴
 * 읽기, 쓰기 모두 빈번
 * 갱신/삭제 연산은 거의 없다.
 * 순차적인 읽기/쓰기가 대부분
#### 선택지1: 데이터베이스
 * 읽기, 쓰기 모두 빈번하게 발생하는 상황을 잘 처리는 DB 설계는 어렵다.
#### 선택지2: WAL(Write-Ahead Log)
 * 새로운 항목이 추가되기만 (append-only) 하는 파일이다.
 * 접근 패턴이 순차적일때 디스크는 아주 좋은 성능을 보인다.
 * 파일 크기는 매우 커질 수 있으므로 세그먼트 단위로 나누는 것이 좋다.
   * 활성 세그먼트를 두고 일정 크기에 도달하면 새 활성 세그먼트 파일을 만들어서 새로운 메시지를 수용하자.
   * 오래된 비활성 세그먼트 파일은 일정 시간이 지나면 삭제해버릴 수 있다.
#### 디스크 성능 관련 유의사항
 * 회전식 디스크가 느리다고 알려져 있지만 이는 랜덤 접근 패턴인 경우다.
 * 순차적으로 데이터 접근 패턴을 활용하면 요구사항을 충족할만한 속도가 나온다.
 * 또한 메모리 캐시를 적극 활용하는 것도 가능하다.
### 메시지 자료 구조
 * 메시지 자료 구조는 생산자, 메시지큐, 소비자 사이의 계약이다
### 메시지 키
 * 메시지의 키는 파티셔을 정할 때 사용된다.
 * 키가 없으면 무작위다. (RR일듯?)

### 생산자 측 작업 흐름
 * 생산자가 어떤 파티션에 메시지를 보낼지, 즉 어느 브로커로 보낼지 결정하는 계층을 라우팅 계층이 있다.
 * 파티션을 여러 개 복제해서 사용하는 경우, 리더 파티션으로 보내야 한다.
 * 라우팅 계층을 따로 두면 네트워크 전송 지연이 발생하므로 이를 생산자 내부에 포함시킨다.
 * (카프카에선 이를 파티셔너라고 한다)
 * 전송 메시지를 버퍼 메모리에 보관했다가 일괄 배치 전송하여 대역폭을 높인다.
 * 얼마나 전송할지는 응답속도와 대역폭의 밸런스로 결정해야 한다.
### 소비자 측 작업 흐름
 * Push vs Pull
   * Push: 지연시간이 낮지만 소비자에게 부하가 크며, 생산량을 예측할 수 없으니 항상 충분한 가용량을 준비해야하는 단점이 있다.
   * Pull: 메시지 소비 속도를 소비자가 결정할 수 있다. 일괄 처리에 적합하다. 브로커에 메시지가 없을수도 있다는 단점이 있다. (이를 개선하기 위해 롱폴링 모드 지원)
#### Pull 모델 동작 흐름

<img src="https://github.com/jaehleeee/study-docs/assets/48814463/153825d8-6263-48ec-83da-87e44466334f" width="500"/>


#### Contoller (브로커 중 하나가 하는 역할)
 * 클러스터 내 브로커에서 장애가 발생하면, 장애가 발생한 브로커 리더 파티션을 정상 브로커로 재배분한다.
 * 컨트롤러 역할의 브로커가에서 장애가 발생하면 다른 브로커가 컨트롤러 역할을 한다 (이 분배는 누가하지? 주키퍼?)
   
#### Coordinator (브로커 중 하나가 하는 역할)
 * 여러 브로커 중 하나가 코디네이터 역할을 한다.
 * 컨슈머 그룹의 상태를 체크하며, 그룹 내 컨슈머 장애가 발생하면 매칭된 파티션을 정상 동작하는 다른 컨슈머로 매칭해준다. (리밸런싱 동작)
 * 소비자 그룹마다 코디네이터가 다르다.

 
<img src="https://github.com/jaehleeee/study-docs/assets/48814463/a65bb90c-90bb-4acb-b187-dd386ecd365a" width="500"/>



### 소비자 재조정
 * 어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스
 * 코디네이터 브로커가 필요하다. 소비자들로오는 heartbreat를 살펴서 각 소비자의 파티션 오프셋을 관리한다. 

#### 새로운 소비자 합류
<img src="https://github.com/jaehleeee/study-docs/assets/48814463/aeef736f-38d1-43af-99d9-593f8bb4a586" width="500"/>

### 기존 소비자 이탈
<img src="https://github.com/jaehleeee/study-docs/assets/48814463/91fe0afa-6649-4406-ba1b-c19572199ee8" width="500"/>

### 기존 소비자 장애
<img src="https://github.com/jaehleeee/study-docs/assets/48814463/34c9ecec-3f6d-4f4e-b173-37d8d642fbe7" width="500"/>


### 상태 저장소


###


###
###
###

## 4단계:

