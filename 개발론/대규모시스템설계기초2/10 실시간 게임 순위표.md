# 1단계: 문제 이해 및 설계 범위 확정

- 점수 계산: 경기에서 승리해서 얻은 포인트로 계산 - 이길 때마다 1점 획득
- 모든 플레이어가 순위표에 포함되어야 함
- 매 달 새로운 순위표를 생성
- 상위 10명과 특정 사용자의 순위를 표시해야 함
- DAU 500만 명, MAU 2,500만 명
- 각 선수는 하루 평균 10경기
- 같은 점수는 같은 순위
- 실시간에 가깝게 표시

## 기능 요구사항

- 순위표에 상위 10명 플레이어를 표시한다.
- 특정 사용자의 순위를 표시한다.
- 어떤 사용자보다 4순위 위 아래 사용자를 표시한다. (보너스 문제)

## 비기능 요구사항

- 접수 업데이트는 실시간으로 순위표에 반영한다.
- 일반적인 확장성, 가용성, 안정성

## 개략적 규모 추정

- DAU 500만 명 → 초당 50명, 피크 시간대 최대 5배로 가정 → 250명/s
- 사용자 점수 획득 QPS: 10개 게임 *  250/s = 2,500
- 상위 10명 순위 가져오기 QPS: 하루에 한 번 게임을 열고, 게임을 열 때만 표시한다고 가정 → 50

# 2단계: 개략적 설계안 제시 및 동의 구하기

## API 설계

3가지 API 가 필요하다

> POST /v1/scores
> 

사용자가 게임에서 승리하면 순위표에서 사용자의 순위를 갱신한다. 게임 서버 내부에서 호출하는 API

request

| 필드 | 설명 |
| --- | --- |
| user_id | 게임에서 승리한 사용자 |
| points | 획득한 포인트 수 |

response

| 이름 | 설명 |
| --- | --- |
| 200 OK | 사용자의 점수를 성공적으로 갱신한 경우 |
| 400 Bad Request | 잘못된 인자가 전달되어 사용자 점수를 갱신할 수 없었던 경우 |

> GET /v1/scores
> 

순위표에서 상위 10명을 가져온다.

```json
{
   "data":[
      {
         "user_id ":"user_id1",
         "user_name ":"alice",
         "rank ":1,
         "score":976
      },
      {
         "user_id":"user_id2",
         "user_name":"bob",
         "rank ":2,
         "score":965
      }
   ],
   ...
   "total":10
}
```

> GET /v1/scores/{:user_id}
> 

특정 사용자의 순위를 가져온다.

| 필드 | 설명 |
| --- | --- |
| user_id | 순위 정보를 가져올 사용자 ID |

response

```json
{
	"user_info": {
		"user_id": "user5",
		"score": 940,
		"rank": 6
	}
}
```

### 개략적 설계안

- 게임 서비스: 사용자가 게임을 플레이 하는 서비스
- 순위표 서비스: 순위표를 생성하고 표시하는 역할
    
![image](https://github.com/user-attachments/assets/ae2f29c8-1d17-44cd-a768-a4fa8bcc8768)

> 클라이언트가 순위표 서비스와 직접 통신해야 하나?
> 

클라이언트가 점수를 정하는 방식이 있을 수 있다. → 사용자가 점수를 바꾸는 중간자 공격이 가능하므로 서버가 점수를 정해야 한다.

> 게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가?
> 

게임 점수가 어떻게 사용되는지에 따라 달라진다. → 다른 곳에서도 이용되거나 여러 기능을 제공할 경우 카프카에 데이터를 넣는 것이 합리적일 수 있다.

## 데이터 모델

순위표 저장소에 사용할 수 있는 3가지 데이터 기술을 보자: RDB, Redis, NoSQL

### RDB

규모 확장 가능성과 사용자 수가 적을 경우

→ 사용자 ID와 점수 열을 갖는 테이블로 표현해, 내림차순으로 정렬

> 특정 사용자의 순위 검색
> 

```sql
SELECT (@rownum := @rownum + 1) AS rank, user_id, score FROM leaderboard
ORDER BY score DESC;
```

단점

- 같은 점수를 받은 사용자가 여럿일 경우, 목록에서의 위치만으로 순위를 알 수 없다.
- SQL DB는 지속적으로 변화하는 대량의 정보를 처리하기 어렵다.

한 가지 최적화: 색인을 추가하고 LIMIT 절을 사용

- 특정 사용자의 순위를 알기 위해 전체를 훑어야 함
- 상단에 있지 않은 사용자 순위를 간단히 찾을 수 없음

### Redis

> 정렬 집합 sorted set
> 

집합과 유사한 자료형

- 저장된 원소는 각 **점수**에 연결되어 있다.
- 집합 내 원소는 고유하지만, 같은 점수를 갖는 원소는 존재 가능

내부적으로 **해시 테이블**과 **스킵 리스트** 자료 구조를 사용한다.

- 해시 테이블: 사용자 점수 저장
- 스킵 리스트: 특정 점수를 딴 사용자 목록 저장
    - 빠른 검색을 가능하게 하는 자료 구조
    - 연결 리스트에 다단계 색인을 두는 구조
        
![image](https://github.com/user-attachments/assets/5017416e-0451-48ea-9818-0d68eada848e)

        이진 검색 알고리즘처럼 중간 지점에 빨리 도달 할 수 있도록 하는 것
        
    
    → 색인을 통해 시간 복잡도가 $O(n)$ *→* $O(log(n))$ 이 가능 
    

> 레디스 정렬 집합을 사용한 구현
> 
- ZADD: 기존에 없던 사용자 삽입, 기존 사용자는 점수 업데이트 $O(log(n))$
- ZINCRBY: 사용자 점수를 지정된 값만큼 증가, 없는 사용자는 0에서 시작 $O(log(n))$
- ZRANGE/ZREVRANGE: 점수에 따라 정렬된 사용자 중 특정 범위의 사용자를 가져온다. 순서, 항목 수, 시작 위치 지정 가능 $O(log(n)+m)$ m: 가져올 항목 수 n: 정렬 집합 크기
- ZRANK/ZREVRANK: 정렬 시 특정 사용자의 위치 $O(log(n))$

> 정렬 집합을 사용한 구현 동작 원리
> 
1. 사용자가 점수를 획득한 경우
    
    ```sql
    ZINCRBY <키> <증분> <사용자>
    ```
    
2. 사용자가 순위표 상위 10명을 조회하는 경우
    
    ```sql
    ZREVRANGE <키> <시작> <끝> WITHSCORES
    ```
    
3. 사용자가 자기 순위를 조회하는 경우
    
    ```sql
    ZREVRANK <키> <사용자>
    ```
    
4. 특정 사용자 기준으로 일정 범위 조회
    
    ```sql
    ZRERANBE <키> <시작> <끝>
    ```
    

### 저장소 요구사항

- 사용자 ID와 점수 저장
    - 최악) DAU가 모두 순위표에 있어야 하는 경우
    - ID 24자, 점수 16비트 정수 → 순위표 항목당 26바이트 ⇒ 약 650MB
- CPU 및 I/O 사용량: 2500 QPS
- 영속성
    - 레디스에 읽기 사본을 두어 사용
- RDB
    - 2개의 테이블 - 사용자 테이블, 점수 테이블
        - 점수테이블: 사용자 ID, 점수, 승리한 시각 등 저장
    - 다른 게임 기능 구현 및 인프라 장애 복구에 사용 가능
    - 자주 검색되는 상위 10명의 정보 캐싱을 통해 최적화

# 3단계: 상세 설계

## 클라우드 서비스 사용 여부

### 자체 서비스 이용 방안

![image](https://github.com/user-attachments/assets/fbb5c605-3f38-4b31-9c87-a5ce9746b264)


- 매월 정렬 집합을 통해 사용자 및 점수 정보 저장
- 사용자 세부 정보는 MySQL에 저장
- 상위 10명 사용자 프로필 캐시

### 클라우드 서비스 이용 방안

아마존 API 게이트웨이, AWS 람다 사용하기

> AWS 람다
> 

: serverless 컴퓨팅 플랫폼

필요할 때만 실행되고, 트래픽에 따라 자동으로 규모확장이 된다.

- 구글 Cloud Function, MS Azure Function

![image](https://github.com/user-attachments/assets/2b02db02-0dd5-4ed2-81c9-73192d98897a)


- 서버 인스턴스 없이 람다를 통해 바로 스토리지 계층을 호출해 결과 전달

## 레디스 규모 확장

5백만 DAU는 한 대의 레디스 캐시 서버로 충분

100배를 고려해보자

### 데이터 샤딩

> 고정 파티션
> 

점수의 범위에 따라 파티션을 나눈다 → 데이터 범위 만큼

: 점수가 고르게 분포되어야 한다.

- 입력/갱신 시: 특정 사용자가 어느 샤드에 있는지 알아야 함 → 사용자 ID - 점수 캐싱을 통해 최적화
- 상위 10명 조회: 가장 높은 점수가 포함돈 샤드의 상위 10명 조회
- 특정 사용자의 순위: 특정 사용자가 포함된 샤드 및 높은 점수 샤드의 모든 사용자 수를 알아야 함 → info keyspace를 통해 $O(1)$에 알 수 있음

> 해시 파티션
> 

레디스 클러스터 사용 → 특정 대역에 점수가 몰려있을 경우 유리

각 키가 특정 해시 슬롯에 속하도록 하는 샤딩 기법을 사용한다. `슬롯 = CRC16(키) % 16384` 로 계산

- 특정 사용자 갱신/조회: 해당 사용자의 샤드를 슬롯 계산으로 찾으면 됨
- 상위 10명 검색: 모든 샤드의 상위 10명을 받아 애플리케이션 내에서 다시 정렬하는 분산-수집을 사용해야 함

⇒ 고정 파티션을 사용한다.

### 레디스 노드 크기 조정

쓰기 연산이 많은 애플리케이션은 메모리를 두 배 더 할당하는 것이 안전

레디스는 성능 벤치마킹을 위한 redis-benchmark 도구를 제공 → 하드웨어로 처리 가능한 초당 요청 수 시뮬레이션 가능

## 대안: NoSQL

- 쓰기 연산에 최적화
- 같은 파티션 내 효율적 정렬 가능
- 아마존 DynamoDB, 카산드라, MongoDB

> 아마존 DynamoDB

기본키primary key 외에 전역 보조 색인global secondary index을 제공한다.

→ 규모 확장이 어려움: 레코드가 많을 경우 상위 점수를 찾기 위해 전체 테이블 탐색이 필요함

`game_name#{year-month}` 를 파티션 키로, 점수를 정렬 키로 사용

→ 부하가 높을 때 문제

→ 최근 한 달치 데이터가 동일 파티션에 저장되고, 핫 파티션이 됨

해결방법

데이터를 n개 파티션으로 분할하고 파티션 번호를 파티션 키에 추가 

→ 읽기, 쓰기 모두 복잡해짐

→ 얼마나 많은 파티셔을 두어야 할까


전역 보조 색인은 `game_name#{year-month}#p{partition_number}` 파티션 키로, 점수를 정렬 키로 사용

상위 10명 사용자 → 분산-수집 접근법 활용
![image](https://github.com/user-attachments/assets/404f8670-bc98-495c-98a2-e52764621e60)


파티션 수는 어떻게 정할까? → 벤치마킹을 통해 파악

사용자의 상대적 순위를 정하는 것이 어렵다 → 백분위 수를 구할 수 있음 

# 4단계: 마무리

### 더 빠른 조회 및 동점자 순위 판정 방안

레디스 해시를 통해 문자열 필드와 값 사이 대응관계를 저장할 수 있음

1. 순위표에 표시할 사용자 ID와 사용자 객체 사이 대응관계 저장: DB 저장 없이 사용자 정보 획득 가능
2. 두 사용자의 점수가 같은 경우: 마지막 승리 시간으로 판단 → 경기 타임 스탬프 정보 저장

### 시스템 장애 복구

MySQL DB를 통해 복구 → 레코드당 한 번 씩 ZINCRBY를 호출하며 복구
