# 7장 호텔 예약 시스템
 * 호텔 체인의 예약 시스템 혹은 에어비앤비, 항공권, 영화 티켓 예매 등의 시스템 설계

## 1단계: 문제 이해 및 설계 범위 확정
### 기본 요구사항
 * 5000개 호텔
 * 100만개 객실
 * 평균 객실 70% 사용, 평균 투숙 3일
 * 10% 초과 예약 가능
 * 요금은 예약시 지불
 * 지원 기능: 호텔 정보 / 객실 정보 / 객실 예약 / 호텔이나 객실 정보 CRUD / 초과 예약 지원
 * 객실 가격은 유동적 - 그날 객실 여유 상황에 딸 ㅏ 다름

### 비기능 요구사항
 * 높은 수준의 동시성
 * 적절한 지연 시간 - 몇 초 정도 걸리는건 괜찮다

### 개략적 규모 추정
 * 일일 예약 건수 = 1백만 객실 * 70% 사용률 / 평균 3일 투숙 = 약 240,000
 * 초당 예약 건수 = 240,000 / 하루 10000초 = 약 3.xxx (트래픽 높지 않음)
 * 시스템 내 QPS는?
   * 보통 웹사이트는 10% 사용자가 다음 단계로 진입한다.
   * 객실 예약 페이지 QPS가 3 이므로 역산 가능
   * 객실 상세 페이지 (QPS:300) -> 예약 상세 페이지 (QPS:30) -> 객실 예약 페이지 (QPS:3)

## 2단계: 개략적 설계안 제시 및 동의 구하기
### API 설계
 * 호텔 관련 API - 호텔 CRUD
 * 객실 관련 API - 객실 CRUD
 * 예약 관련 API - 예약 이력, 신규 예약, 예약 취소 등
 * reservation_id가 이중 예약을 방지하는 멱등 키 이다.

### 데이터 모델
 * 어떤 DB 사용할지 결정하기 전에 데이터 접근 패턴부터 살펴봐야 한다.
   * 호텔 상세 정보 / 해당 날짜 사용 가능 객실 유형 확인 / 예약 정보 확인 / 예약 내역 확인
 * 대규모 이벤트가 있다면 트래픽 급증 가능 -> 대비 필요
 * 읽기 빈도가 쓰기보다 높으므로 관계형 DB 로 결정.
   * 특히 ACID 속성은 예약 시스템 만들때 중요
   * 데이터 모델링도 쉽다.
 * 데이터 모델에서 주요한 부분은 reservation 테이블의 status 필드
   * pending, paid, refund, canceled, rejected
 * 스키마 디자인에서 문제가 될 수 있는 부분은 room_id 이다.
   * 에어비앤비 같은 회사엔 적합하지만, 호텔은 아니다.
   * 사용자는 특정 객실을 예약하지 않고 객실 유형으로 예약한다.
   * 나중에 개선하자. 

### 개략적 설계안
 * MSA 아키텍쳐
 * 공개 API 게이트웨이 : 처리율 제한, 인증 등의 기능 지원하며, 엔드포인트 기반으로 요청을 전달한다.
 * 내부 API : 승인된 호텔 직원만 사용, VPN 등의 기술로 외부 공격으로부터 보호
<img src="https://github.com/user-attachments/assets/514a0991-8ba0-4e48-b62a-8660387d1bd7" width="550"/>


## 3단계: 상세 설계
### 개선된 데이터 모델
 * roomId를 roomTypeId 로 변경 필요.
 * room_type_rate: 특정 객실 유형의 특정 일자 요금 정보를 담는다.
 * room_type_inventory: 호텔 모든 객식 유형을 담는다.
   * total_inventory: 총 객실 수 에서 일시적으로 제외한 객실은 뺸 값
   * total_reservced: 지정된 객실과 날짜에 예약된 객실 수
   * 테이블의 PK : hotel_id + room_type_id + date 복합키
     * 이렇게 해야 해당 호텔의 해당 객실의 해당 날짜 예약을 쉽게 관리할 수 있다.
 * 10% 초과 예약 가능하게 하는 쿼리
   * `if (total_reserved + ${nuberOfRoomToReserve}) <= 110% * total_inventory)` true 일때.

<img src="https://github.com/user-attachments/assets/246fb778-4a7d-4517-909a-16e12c1e960b" width="550"/>


### 동시성 문제
#### 동시성 문제 발생 2가지 시나리오
 1. 같은 사용자가 예약 버튼을 여러번 누를 때
 2. 여러 사용자가 같은 객실을 동시에 예약하려 할때

#### 시나리오1 - 같은 사용자가 예약 버튼을 여러번 누를 때
해결방안 접근법 2가지
 * 클라이언트측 : 요청 전송 후 예약 버튼 숨기기, 그 다지 안정적인 방법은 아니다.
 * 멱등 API: 예약 api 요처에 멱등키 추가. 몇번을 호출해도 같은 결과를 내는 api
    * reservation_id를 유일성 보증 ID로 활용 

<img src="https://github.com/user-attachments/assets/f13289b7-029d-4782-bd0f-3763c1b412ed" width="550"/>

#### 시나리오2 - 여러 사용자가 같은 객실을 동시에 예약하려 할때
<img src="https://github.com/user-attachments/assets/7b4921a0-3301-4eff-8eee-ff233e3c9e33" width="550"/>
해결방안 3가지
 * 비관적 락
 * 낙관적 락
 * 데이터베이스 제약 조건 constraint

예약 진행시 사용하는 쿼리 순서
1. 예약 가능 객실 현황 확인
2. 방이 110% 이상 예약되지 않았는지 체크
3. 객실 예약
4. 커밋

#### 비관적 락 (권장X)
 * 레코드가 갱신하려는 순간 즉시 락을 걸어 동시 업데이트 방지하는 기술
 * 장점
   * 변경중인 데이터 갱신을 막을 수 있다.
   * 구현이 쉽고 모든 갱신 연산을 직렬화하여 충돌을 막는다.
   * 경합이 심할때 유용
 * 단점
   * 데드락 발생 가능
   * 확장성이 낮다. 트랜잭션이 락을 너무 오래 가지고 있으면 다른 트랜잭션이 자원 접근성이 떨어진다.
   * 성능에 영향을 끼친다.

<img src="https://github.com/user-attachments/assets/3568b06d-e94c-40d0-94a0-f09a3c593f5f" width="550"/>

  
#### 낙관적 락 (권장O)
 * 여러 사용자가 동시에 같은 자원을 갱신하려 시도하는 것을 허용
 * 버전 번호와 타임 스탬프 2가지 방법을 구현 가능. (일반적으로 버전을 더 나은 선택지로 봄)
 * 사용자가 레코드를 갱신하려할때 버젼을 통해 유효성 검사를 한다. (나보다 빠르게 갱신한 사람이 있는지 체크)
    * 유효성 검사 실패시 트랜잭션 중단되고 처음부터 다시 시도
 * 비관적 락보다 빠르지만 동시성 수준이 높으면 성능이 급격하게 나빠진다.
 * 충돌이 발생하면 늦은 클라이언트는 재시도해야 한다.
 * 최종 결과는 정확하겠지만 반복되는 재시도 때문에 사용자는 불쾌한 경험을 할 수 있다.
 * 장점
   * 애플리케이션이 유효하지 않은 데이터 편집을 막는다.
   * 디비에 락을 걸 필요가 없다.
   * 경쟁이 치열하지 않은 상황에 적합.
 * 단점
   * 경쟁이 치열하면 성능이 좋지 않다.
<img src="https://github.com/user-attachments/assets/fc093993-e465-4c35-a5aa-68c23a98b653" width="550"/>


#### 데이터베이스 제약 조건 constraint
 * 낙관적 락과 유사
 * 테이블에 아래 제약 조건을 추가한다.
 * 아래 제약 조건을 위반하는 트랜잭션은 중단되고 데이터는 롤백된다.
 * 장단점도 낙관적 락과 유사.
```
CONSTRAINT `check_room_count` CHECK((`total_inventory - total_reservded` >= 0))
```
<img src="https://github.com/user-attachments/assets/d3cb1191-a791-497d-8968-7faadce6848e" width="550"/>


### 시스템 규모 확장
 * 시스템 규모를 확장할때는 부하가 높을때 무엇이 병목이 될 수 있을지 이해해야 한다.
 * 서버는 무상태 서버이므로 서버 추가로 확장 가능
 * 데이터베이스는 샤딩

#### 캐시
 * 캐시는 TTL과 LRU 캐시 교체 정책을 활용하여 메모리 최적화
   * 잔여 객실 확인과 객실 예약 로직 실행
   * 캐시 데이터는 변경되었을 수 있으니 최종 확인은 db 에서 해야한다.
   * 잔여 객실 데이터 갱신시, db가 먼저 갱신되고 캐시는 비동기로 반영된다
   * 이때 CDC 변경 데이터 감지 매커니즘도 있다.
 * 장점
   * 읽기 질의를 캐시가 처리하므로 DB 부하가 크게 줄어든다.
   * 읽기 질의를 메모리에서 실행하므로 높은 성능
 * 단점
   * db와 캐시 사이에 데이터 일관성 문제 발생 가능.    


### MSA 데이터 일관성 문제 해결
 * 모노리스 아키텍처에서는 관계형 DB를 공유하는 것이 보통이다.
 * MSA에서는 각 서버가 독자적인 db 갖추는게 일반적인 방식이다.
   * 이럴 경우 데이터 일관성 문제가 발생할 수 있다.
   * 하나의 트랜잭션으로 데이터 일관성을 보증할 수 없다.
 * 데이터 일관성을 해결하는 방법은
   * 2단계 커밋 (2 phase commit)
     * 여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜
     * 어느 한 노드에 장애가 발생하면 해당 장애가 복구될 때까지 진행이 중단된다.
     * 성능이 뛰어나진 않음.
  * 사가
     * 각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮은 것
     * 한 트랜잭션이 완료되면 다음 트랜잭션의 트리거
     * 하나가 실패하면 이전 트랜잭션을 되돌리는 트랜잭션도 순차적으로 실행

## 4단계: 마무리
수고하셨습니다.


