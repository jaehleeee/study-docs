# 2장 주변친구
 * 앱 사용자 가운데 본인 위치 정보 접근 권한을 허락한 사용자에 한해 인근의 친구 목록을 보여주는 시스템
 * 근접성 서비스와 비슷해보이지만, 주변 친구 위치는 사업장 주소와 다르게 매번 바뀌므로 큰 차이가 있다.

## 1단계: 문제 이해 및 설계 범위 확정
### 기능 요구사항
 * 주변 친구 정보과 거리, 마지막 갱신 시간 함께 표시
 * 친구 목록은 몇초에 한번씩 갱신
### 비기능 요구사항
 * 낮은 지연시간
 * 안정성 : 몇개의 데이터가 유실되는 것은 용인 가능
 * 결과적 일관성 (강하지 않은 일관성) : 복제본 데이터가 원본과 동일하게 되기까지 몇초 걸리는 것은 용인 가능
### 개략적 규모추정
 * 주변친구는 5마일 반경으로 한다.
 * 친구 위치는 30초 주기 갱신한다.
 * 사용자는 1억명
 * 동접자는 DAU의 10% -> 1000만명.
 * 평균 1인당 400명 친구 가진다.
 * 앱 최초 조회시 20명만 보여주고 추가 요청시 더 보여준다.
 * QPS : 천만/30초 -> 334,000

## 2단계: 개략적 설계안 제시 및 동의구하기

### 개략적 설계안
 * 사용자는 근방의 모든 활성 상태 친구의 새 위치 정보를 수신하고자 한다.
 * 이론적으로는 순수한 P2P 방식으로도 해결 가능한 문제다.
 * 다시 말해, 활성 상태인 근방 모든 친구와 항구적 통신 상태를 유지하면 되는 것이다.
 * 좀 더 실용적인 설계안은 공용 백엔드 사용이지만, 규모를 키우기 어렵다는 단점이 있다.

### 설계안
#### 웹소켓 서버
 * 친구 위치 정보 변경을 거의 실시간에 가깝게 처리하는 유상태 서버 클러스터
 * 각 클라이언트는 그 가운데 한 대와 웹소켓 연결을 지속 유지한다.
 * 주변 친구 기능을 이용하는 클라이언트의 초기화도 담당한다. 모바일 클라이언트가 시작되면 온라인 상태인 모든 주변 친구 위치를 해당 클라이언트로 전송하는 역할을 한다.
#### 레디스 위치 정보 캐시
 * 활성 상태인 사용자의 가장 최근 위치 정보 캐시
#### 레디스 펍/섭 서버
 * 레디스 펍/섭은 초경량 메시지 버스다.
 * 레디스 펍/섭에서의 새로운 채널 생성은 아주 값싼 연산이다.
 * 사용자마다 채널을 생성하고, 위치가 갱신되면 채널로 이를 전송한다. 그럼 이 사용자와 구독관계인 친구들 모두가 이 정보를 수신한다.

<img src="https://github.com/jaehleeee/study-docs/assets/48814463/f39bf370-9daa-4f0d-a5b3-0786c243ff50" width="500"/>

#### 주기적 위치 갱신 과정
1. 클라이언트가 위치가 변경된 사실을 로드밸런서로 전송
2. 로드밸런서는 웹소켓 서버로 전송
3. 웹소켓 서버는 해당 이벤트를 위치 이동 이력 DB에 저장 및 위치 정보 캐시에 보관 (TTL 갱신)
4. 웹소켓 서버는 레디스 펍/섭 서버에 해당 사용자 채널에 새 위치 정보를 발행
5. 이를 구독하는 구독자에게 브로드캐스트된 위치 정보를 받은 구독자들은 이벤트를 수신
6. 수신된 정보를 받은 사용자들은 신규 거리 측정
7. 이 거리가 검색 반격을 넘지 않으면 해당 타임스탬프와 위치 정보를 구독자의 클라이언트 앱으로 전송

<img src="https://github.com/jaehleeee/study-docs/assets/48814463/a95b7246-ff91-4eb3-aa54-957a0e5fb3ea" width="500"/>

### API 설계
 * 특이사항 없음.

### 데이터 모델
 * 위치 정보 캐시는 '주변친구' 기능을 켠 활성 상태 친구의 가장 최근 위치를 보관한다
#### 위치 정보 저장에 데이터베이스를 사용하지 않는 이유는?
 * 현재 위치만을 이요하기 때문이다.
 * 따라서 사용자 위치는 하나만 보관하면 충분하다.
 * TTL을 지원하므로 활성 상태가 아닌 사용자 정보를 자동으로 제거할 수 있다.
 * 즉, 영속성을 보장할 필요가 없으면서 읽기 및 쓰기 연상 속도가 빠르다는 장점을 잘 활용할 수 있다.
#### 위치 이동 이력 DB
 * 막대한 쓰기 연산 부하를 감당하면서 수평적 규모 확장이 가능한 카산드라가 좋음.
 * 데이터가 많을 수 이씅니 샤딩 필요. (사용자 ID를 key 설정)

## 3단계: 상세 설계

### 중요 구성요소별 규모 확장성
#### API 서버
#### 웹소켓 서버
#### 클라이언트 초기화


### 레디스 펍/섭

### 친구 관련


