# 8장 분산 이메일 서비스

## 1단계 : 문제 이해 및 설계 범위 확정
- 10억 명
- 인증 X,
- 이메일 발송/수신, 이메일 가져오기, 읽음 여부에 따른 필터링, 제목/발신인/메일 내용에 따른 검색 기능, 스팸 및 바이러스 방지 기능
- SMTP, POP, IMAP 은 구식. HTTP를 사용한다고 가정
- 첨부 파일도 지원

---
### 비기능 요구사항

- 안정성 : 이메일 데이터는 소실되어서는 안 된다.
- 가용성 : 여러 노드에 자동으로 복제, 부분 장애도 동작해야함
- 확장성 : 시스템 성능은 사용자/이메일이 늘어나도 저하되지 않아야 한다
- 유연성과 확장성 : 쉽게 기능 추가 성능 개선, POP, IMAP은 기능이 제한적

### 개략적인 규모 추정
- 10억명, 하루에 평균 10건 → 전송 QPS = 100,000
- 하루에 수신하는 평균 이메일 수는 40건, 메타데이터는 평균 50KB (이메일의 모든 정보, 첨부 파일은 포함하지 않음)
- 메타데이터는 DB에 저장. 1년에 730PB
- 첨부 파일을 포함하는 이메일의 비율은 20%, 평균 크기 500KB
- 1년에 1460PB

## 2단계 : 개략적 설계안 제시 및 동의 구하기
### 이메일 101
지금까지 대부분의 메일 서버는 POP, IMAP, SMTP 같은 프로토콜을 사용
- STMP : Simple Mail Transfer Protocol
    - 이메일을 서버에서 다른 서버로 보내는 표준 프로토콜
- POP, IMAP : 이메일을 가져오는 목적으로 사용되는 프로토콜
    - POP : 단말로 다운로드된 이메일은 서버에서 삭제. 1대 단말만 읽을 수 있게 됨. 전부 다운받는 구조라, 용량이 큰 첨부 파일이 붙은 이메일은 오래걸림
    - IMAP : POP과 달리 클릭하지않으면 메시지는 다운로드 되지 않음. 메일 서버에서도 지워지지 않음. 여러 단말에서 읽을 수 있음.
        - 개인 이메일 계정에서 널리 사용. 헤더만 다운로드 인터넷느려도 됨

### DNS
- MX 레코드가 있음 (Mail Exchange)
- 우선순위가 존재. 낮으면 높음.

### 첨부 파일
이메일 메시지와 함께 전송, Base64 인코딩을 사용. 크기 제한이 있음

### 전통적 메일 서버
- 보통 메일 서버 한 대로 운용되는, 사용자가 많지 않을 때 잘 동작하는 시스템

![image](https://github.com/user-attachments/assets/bbedbfa4-a44e-4b08-b428-72c60b326839)

저장소는 파일 시스템의 디렉터리에 저장. 
각각의 이메일은 고유한 이름을 가진 별도 파일로 보관

<aside>
💡 메일의 양이 많아지고, 파일 구조가 복잡해지면 병목이 발생. 가용성, 안정성 요구사항도 X
* 안정적인 분산 데이터 저장소 계층이 필요

</aside>

추자거으로, POP/IMAP/SMTP 같은 프로토콜은 오래전에 발명되어서, 검색/레이블 등의 다양한 기능제공에 어려움이 존재

---

## 분산 메일 서버

현대적 사용 패턴을 지원, 확장성과 안정성 문제를 해결한다. 

### 이메일 API
이메일 API의 의미는 메일 클라이언트마다, 생명주기 단계마다 달라질 수 있음. 

1. POST /v1/messages 엔드포인트
    1. To, Tc, Bcc 헤더에 명시된 수신자에게 메시지를 전송한다. 
2. GET /v1/folders 헨드포인트
    1. 주어진 이메일 계정에 존재하는 모든 폴더를 반환한다.
3. GET /v1/folders/{:folder_id}/messages 엔드포인트
    1. 주어진 폴더 아래의 모든 메시지를 반환한다. 
    2. 지극히 단순화한 명세. 실제로는 페이지 분할 등으로 복잡할 수 있음
4. GET /v1/messages/{:message_id} 엔드 포인트

---

### 분산 메일 서버 아키텍처
전통적인 이메일 서버가 단일 장비 위에서만 동작하도록 설계되어있음. 그래서 규모를 늘리기 어려움. 
여러 서버 사이에 데이터를 동기화 하는 것은 어려운 작업. 
→ 수신자 메일 서버에서 이메일이 스팸으로 잘못 분류되지 않도록 하려면 아주 까다로운 문제들을 풀어야 함.

![image](https://github.com/user-attachments/assets/5a58f980-7b96-4721-9ce6-3f43625ea90f)

- 웹메일 : 사용자는 웹브라우저를 사용해 메일을 받고 보냄
- 웹서버 : 요청/응답 서비스, 로그인, 가입, 사용자 프로파일 등에 대한 관리 기능을 담당. 모든 API 요청은 전부 웹서버를 통함
- 실시간 서버 : 새로운 이메일 내역을 클라이언트에 실시간으로 전달하는 역할을 담당. 상태 유지(stateful) 서버
    - long polling / websocket
    - 웹소켓을 쓰되, 여의치 않으면 롱 폴링을 백업으로 이용
- 메타데이터 데이터베이스 : 이메일 제목, 본문, 발신인, 수신인 목록 등이 메타데이터 저장
- 첨부 파일 저장소 : S3 가 적당
    - 카산드라 같은 NoSQL은 → BLOB 자료형을 지원하지만, 실질적으로 부적절
        - 메모리를 너무 잡아먹음
- 분산 캐시 : 레디스
- 검색 저장소 : 분산 문서 저장소, 역 인덱스 구조를 사용

---

## 이메일 전송 절차
- 서비스 내부 전송인 경우, 4를 거칠 필요가 없음.
- 외부 전송인 경우, 4를 통해 Queue를 통해 의존성 분리.
![image](https://github.com/user-attachments/assets/60be33e4-8d26-4960-8c45-aea2b50bfc18)

## 이메일 수신 절차
- 이메일이 SMTP LB에 도달
- 이메일의 첨부파일이 너무 크면, S3에 보관
- 큐에 넣고, 메일처리하고 → 이메일을 보관
- 수신자가 온라인 상태인 경우 → 실시간 서버로 전달
    - ws 서버
- 오프라인은 RESTfulAPI
![image](https://github.com/user-attachments/assets/10bc0b67-af2d-4397-84cf-4a29e1538208)


## 3단계 : 상세 설계
몇 가지 핵심 요소에 대해 더 자세히 알아보고 규모 확장 방안을 점검

## 메타데이터 DB
- 이메일 헤더는 작고, 빈번하게 이용
- 본문의 빈도는 낮음. 일반적으로 1번만 읽음
- 이메일 관련 작업은 사용자별로 격리 수행되어야하고
- 사용자는 보통 최근 메일만 읽음
- 데이터 손실은 용납 X

### 올바른 DB 선정

- RDBMS : 데이터 크기가 크면 부적절. 본문저장이 어려움. BLOB은 성능이 떨어짐
- S3 : 백업 데이터 보관으로는 좋지만, 읽음표시, 키워드검색, Thread 기능 구현에는 X
- NoSQL : 지메일은 BigTable. 하지만 구현은 비공개. 카산드라가 좋은 대안이 될 수도있겠지만, 대형 이메일 중에 확인된 바는 없음.

<aside>
💡 대형 이메일 서비스 업체는 대체로 독자적인 DB 시스템을 만들어 사용
(works는 큐브리드 쓴대여)

</aside>

![image](https://github.com/user-attachments/assets/f3efa520-4583-478f-b0dd-6ff511bc853b)

- 분산 DB를 설계할 수는 없으므로, DB가 위의 조건을 충족해야 한다는 점은 설명할 수 있도록 한다.

---

### 데이터 모델

- user_id를 파티션 키로 사용하여 샤드에 같게 보관.
- 클러스터 키 - 같은 파티션에 속하는 데이터를 정렬하는 구실

이메일 서비스의 데이터 계층은, 다음과 같은 질의를 지원해야 함

- 주어진 사용자의 모든 폴더를 구한다.
- 특정 폴더 내의 모든 이메일을 표시한다.
- 메일을 새로 만들거나, 삭제하거나, 가져온다.
- 이미 읽은 메일 전부, 또는 아직 읽지 않은 메일 전부를 가져온다.
- 보너스 점수를 받을 수 있는 질의 : 이메일 타래를 전부 가져온다.

질의 1: 특정 사용자의 모든 폴더 질의

→ 같은 파티션안에 있는 데이터를 가져오면 된다. (user_id)

질의 2: 특정 폴더에 속한 모든 이메일 표시

→ <user_id, folder_id> 처럼 복합 파티션 키를 사용한다. email_id 시간 정렬용 클러스터 키 (timeuuid)

질의 3: 이메일 생성/삭제/수신
→ 지면 관계로 이메일 상세 정보를 가져오는 방법만 설명. 
SELECT * FROM emails_by_user WHERE email_id=123;
를 통해 특정 이메일의 상세 정보를 가져옴. filename 필드를 통해서 첨부 파일도 질의


질의 4: 읽은, 또는 읽지않은 모든 메일
관계형 DB가 아니라고 가정, is_read 필드는 파티션 키, 클러스터 키가 아님 (NoSQL은 보통 파티션 키, 클러스터 키만 질의 허용)
→ 애플리케이션 단에서 필터링? → 대규모 서비스에서는 그다지 적합하지 않음.

<aside>
💡 보통은, 비정규화하게된다. emails_by_folder 테이블을 2개로 분할
* read_emails : 읽은 상태의 모든 이메일을 보관하는 테이블
* unread_emails : 읽지않은 모든 이메일을 보관하는 테이블
읽지않음 → 읽음으로 변경할때, 이메일을 삭제 → 옮김
</aside>

보너스 : 이메일 타래 (스레드) 가져오기
- JWZ 같은 알고리즘을 통해 구현된다고 한다.
이러한 필드들을 통해, 타래 내의 모든 메시지가 사전에 메모리로 로드되어 있는 경우, 전체 대화 타래를 재구성해 낼 수 있게 된다.

### 일관성 문제
- 모든 메일함이 하나의 primary 사본을 통해 서비스된다고 가정해야 한다.

---

## 이메일 전송 가능성
보통 메일의 50%는 스팸으로 분류된다고 한다. 새로 구성한 메일 서버는 대부분 스팸. 평판이 낮기때문

이를 위해,

- 전용 IP : 보통 아무 이력이 없는 IP 새로운 IP 주소에서 온 메일을 무시함
- 범주화 : 마케팅 목적의 이메일은 중요한 이메일과 같은 서버에서 발송하지 말라. 중요한게 다 필터링 될 수 있음
- 발신인 평판 : 새로운 이메일 서버의 IP 주소는 사용 빈도를 서서히 올리는 것이 좋음. 스팸 분류 가능성이 낮아지기 위해.
- 스팸 발송자의 신속한 차단이나, 피드백을 빠르게 처리한다.

<aside>
💡 이메일이 목적지에 잘 도착하기위해서는, 도메인 지식도 필요하고, ISP와 좋은 관계를 유지해야한다.
</aside>

## 검색
이메일 검색을 제공하려면, 이메일이 전송/수신/삭제 될때마다 indexing 작업 수행이 필요. 
상대적으로 쓰기 연산이 훨씬 많이 발생. 

<aside>
💡 ES 사용과, 데이터 저장소 기본 내장 검색 기능 방안 2가지를 비교
</aside>

### 방안 1: ES
![image](https://github.com/user-attachments/assets/e79e5bce-de84-4052-8d96-0d51d7ff9b95)


### 방안 2: 맞춤형 검색 솔루션
보통 자체 검색 엔진을 개발한다고 함. 여기서는 디스크 I/O 병목 문제만 간단하게 다루도록 함.
이메일 색인 서버의 주된 병목은 보통 디스크 I/O (매일 저장소에 추가되는 양은 페타바이트)
그러므로, LSM 트리를 쓰는게 바람직함

<aside>
💡 대부분의 현대 데이터 저장소는 LSM Tree 기반. 아닌 솔루션 찾기가 힘듬
</aside>

- 소규모 이메일 시스템 구축에는 ES가 좋음.

## 규모 확장성 및 가용성

- 대부분 사용자의 데이터 접근 패턴은 독립적 → 대부분의 컴포넌트는 수평적으로 규모 확장이 가능
- 다중화를 실시하는게 좋음

---

## 4단계 : 마무리
추가로 논의하면 좋은 사항들.
- 결함 내성 : 노드 장애, 네트워크 이슈, 이벤트 전달 지연 등
- 규정 준수, 보안, 최적화(스토리지 최적화)
