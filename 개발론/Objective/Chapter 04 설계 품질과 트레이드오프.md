- 객체지향 설계의 핵심은 **역할, 책임, 협력**
    - 협력 : 앱의 기능을 구현하기 위해 메시지를 주고 받는 객체들 사이의 상호작용
    - 책임 (가장 중요) : 객체가 다른 객체와 협력하기 위해 수행하는 행동 
    - 역할 : 대체 가능한 책임의 집합
- 객체지향 설계란?  
    : 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동
- 설계는 변경을 위해 존재하고, 변경에는 어떤 식으로든 비용이 발생한다.
- 훌륭한 설계란 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것.

# 01 데이터 중심의 영화 예매 시스템

- 객체지향 설꼐 2가지 방법으로 시스템을 객체로 분할 가능
    - 객체의 상태를 분할의 중심축 : 객체 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의 → 객체를 독립된 데이터 덩어리로 본다
    - 책임을 분할의 중심축 : 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관 → 객체를 협력하는 공동체의 일원으로 본다
- 객체의 상태는 객체가 저장해야 하는 데이터의 집합 의미
    - 상태를 데이터와 동일한 의미로 사용 가능
- 왜 책임에 중심축을 둔 설계를 해야할까?
    - 변경과 관련
    - 객체의 상태는 구현에 속한다.
        - 구현은 불안정해서 변하기 쉽다.
        - 그래서 상태를 분할의 중심축으로 삼으면 구현 세부사항이 인터페이스에 스며들게 되어 캡슐화 원칙이 무너진다.
    - 그에비해 책임은 인터페이스에 속한다.
        - 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화한다.

  

#### 데이터를 준비하자

- 데이터 중심의 설계란 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할하는 방법이다.
    - 객체 내부에 무엇을 저장해야 하는가로 시작한다.
- 가장 큰 차이점 : 할일 조건의 목록이 Movie 객체 안에 포함된 것
- 객체지향의 가장 중요한 원칙 : 캡슐화
    - 이를 달성할 수 있는 가장 간단한 방법 : 접근자 + 수정자 추가

#### 영화를 예매하자

- ReservationAgency : 데이터 클래스들을 조합해서 영화 예매 절차를 구현하는 클래스
- 크게 2가지 기능으로 구성
    - 할인조건 리스트를 하나씩 돌면서 할인 가능여부 체크
    - 할인 여부에 따른 적절한 요금 계산

# 02 설계 트레이드오프

- 데이터 중심 vs 책임 중심
- 비교를 위해 캡슐화, 응집도, 결합도를 사용

#### 캡슐화

- 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로 부터 감추기 위해서다
- 여기서 구현이란 나중에 변경될 가능성이 높은 어떤 것을 가리킨다.
- 설계가 필요한 이유는 요구사항이 변경되기 때문
- 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문
- 객체 내부의 무엇을 캡슐화 해야 하는가?
    - **변경될 수 있는 어떤 것이라도 캡슐화해야 한다.**

  

#### 응집도와 결합도

- 응집도
    - 모듈에 포함된 **내부 요소**들이 연관돼 있는 정도
    - 모듈내 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도
- 결합도
    - **모듈들 간의 관계**
    - 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지
    - 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있따면 두 모듈은 낮은 결합도
- 좋은 설계란
    - 높은 응집도와 낮은 결합도 → 설계를 변경하기 쉽게 한다.
    - **오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계**
- 변경 관점에서 응집도
    - 하나의 변경을 수용하기 위해 모듈 전체가 변경되어야 한다면? 응집도가 높은 것
    - 응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다.
- 변경 관점에서 결합도
    - 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
    - 결합도가 높을수록 함께 변경해야 하는 모듈의 수가 늘어난다
- 마지막으로 캡슐화의 정도가 응집도와 결합도에 영향을 미친다는 사실을 강조하고 싶다.
    - 응집도와 결합도를 고려하기 전에 먼저 캡슐화를 향상시키기 위해 노력하라.

# 03 데이터 중심의 영화 예매 시스템의 문제점

- 기능적인 측면에서보면 2장에서 설계한 책임 중심 설계와 동일하지만, 설계 관점에서는 완전히 다르다.
- 근본적인 차이점은 캡슐화를 다른는 방식이다.
    - 데이터 중심 : 캡슐화를 위반하고 객체 내부 구현을 인터페이스의 일부로 만든다.
    - 책임 중심 : 객체 내부 구현을 안정적인 인터페이스 뒤로 캡슐화
- 3가지 문제점
    - 캡슐화 위반
    - 높은 결합도
    - 낮은 응집도

#### 캡슐화 위반

- 접근자와 수정자 메서드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다.
- 설계할 때 협력에 관해 고민하지 않으면 캡슐화를 위반하는 과도한 접근자와 수정자를 가지게 되는 경향이 있다.
- 접근자와 수정자에 과도하게 의존하는 설계 방식을 추측에 의한 설계 전략이라고 부른다.

#### 높은 결합도

- 객체 내부 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미
- 더 나쁜 소식
    - 단기 객체 내부 구현을 변경했음에도 이 인터페이스에 의존하는 모든 클라이언트들도 함께 변경해야 한다는 것
- 대부분의 제어 로직을 가지고 있는 제어 객체인 ReservationAgency가 모든 데이터 객체에 의존한다는 것을 알 수 있다.

#### 낮은 응집도

- 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말한다.

##### 단일 책임 원칙 from 로버트 마틴

- **클래스는 단 한가지의 변경 이유만 가져야 한다.**

# 04 자율적인 객체를 향해

#### 캡슐화를 지켜라

- 캡슐화는 설계 제 1 원리
- 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.
- 속성의 가시성을 private으로 설정했다고 해도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡슐화를 위반하는 것
- 사각형 클래스 예시
    - left, right, top, bottom private 필드가 있고 각 필드는 public 메서드로 수정 가능하다.
    - 그리고 외부 어떤 클래스에서 이 사각형의 너비와 높이를 증가시키는 메서드가 하나 있다.
    - 문제점 2가지
        - 코드 중복 발생 확률이 높다
            - 다른 곳에서도 사각형 너비, 높이 증가시키려할때 메서드가 추가될 것이기 때문
        - 변경에 취약
            - (가로, 세로만 변경되어야 하는데, 4가지 변 모두 변경가능한 점이 취약 포인트 인듯)

#### 스스로 자신의 데이터를 책임지는 객체

- 객체는 단순 데이터 제공자가 아님
- 객체 내부 저장 데이터보다 객체가 협력에 참여하며 수행할 책임을 정의하는 오퍼레이션이 중요
- 이 객체에 어떤 데이터를 포함해야 하는가? 라는 질문은 다음 2개의 질문으로 분리해야 한다
    - 이 객체가 어떤 데이터를 포함해야 하는가
    - 이 객체가 **데이터에 대해 수행해야 하는 오퍼레이션**은 무엇인가

# 05 하지만 여전히 부족하다

#### 캡슐화 위반

- 자신의 데이터는 각 객체들이 처리하고 있다, 그러나 여전히 캡슐화 위반이 있다.
- discountCondition에 구현된 2개의 isDiscountable 메서드를 살펴보면 이상한 점이 있다.
    - 메서드 시그니처를 보면 파라미터로 요일이나 시간 정보가 보인다.
    - 이 필드들은 이미 내부에 가지고 있는필두이기 때문에 외부에 노출할 필요가 없다.
    - 이 필드를 수정하게 되면, 이 메서드를 사용하는 외부 클라이언트도 수정이 필요해진다.
    - 내부 구현 변경이 외부로 퍼져나가는 **파급 효과**는 캡슐화 부족의 명백한 증거다.

#### 높은 결합도

- 내부 구현이 외부로 노출되었으므로, 결합도는 높아진다.
- 한 객체의 구현 변경시 다른 객체에게 변경 영향이 전파된다.

  

#### 낮은 응집도

- 하나의 변경을 수용하기 위해 코드의 여러 곳을 동시에 변경해야 한다는 것은 설계 응집도가 낮다는 증거다.

  

# 06 데이터 중심 설계의 문제점

- 데이터 중심 설계가 변경에 취약한 이유
    - 너무 이른 시기에 데이터에 관해 결정
    - 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

#### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다

- 데이터 중심 관점에서 객체는 그저 단순한 데이터 집합체일 뿐

  

#### 데이터 중심 설게는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.

- 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가아니라 외부에 맞춰져 있어야 한다.
- 중요한 것은 객체가 다른 객체와 협력하는 방법이다.
