- 상속과 합성은 객체지향 프로그래밍에서 가장 널리 사용되는 코드 재사용 기법
    - 상속
        - 부모와 자식 클래스를 연결해서 부모 클래스 코드 재사용
        - 컴파일 타임 의존성
        - is-a 관계
    - 합성
        - 전체를 표현하는 개체가 부분을 표현하는 개체를 포함해서 부분 객체의 코드를 재사용한다.
        - 런타임 의존성
        - has-a 관계
- 상속의 단점
    - 부모클래스와 자식클래스의 높은 결합도
- 반면에, 합성은 구현에 의존하지 않는다. 퍼블릭 인터페이스에 의존

# 01 상속을 합성을 변경하기

#### 상속의 3가지 문제

- 불필요한 인터페이스 상속 : 부적합한 부모 클래스의 오퍼레이션이 상속된다.
- 메서드 오버라이딩 오작용 문제 : 자식 클래스가 부모 클래스의 메서드 호출 방법에 영향
- 부모와 자식 클래스의 동시 수정 문제 : 부모 클래스 변경시 자식도 함께 변경

##### 상속 → 합성 : 상속 관계를 인스턴스 변수로 포함시켜라

#### 불필요한 인터페이스 상속 : 부적합한 부모 클래스의 오퍼레이션이 상속된다.

- 부모 클래스의 불필요 오퍼레이션을 제공 → 클라이언트는 정의된 오퍼레이션만 사용가능하다

#### 메서드 오버라이딩 오작용 문제 : 자식 클래스가 부모 클래스의 메서드 호출 방법에 영향

- 자식클래스가 부모클래스의 메서드(super.method)를 썼을 경우, 부모 클래스와 일부 동작이 겹치면서 오작동
- super.method를 안쓴다면? 비슷한 메서드를 중복으로 만들어야하는 문제가 있다.
- 상속 대신 합성으로 해결
    - 기존 제공해야할 인터페이스는, HashSet 대신 Set 인터페이스를 상속 후 합성으로 가지고 있는 클래스의 메서드로 해결 (포워딩 이라고 부른다)

#### 부모와 자식 클래스의 동시 수정 문제 : 부모 클래스 변경시 자식도 함께 변경

- 부모 클래스의 메서드 (오버라이딩 말고)를 썼을때 같이 수정하는 경우가 발생할 수 있다.
- 이 문제는 합성으로 변경해도 여전하지만, 그래도 캡슐화되어 있어서 파급효과가 제한된다.
- 대부분의 경우 구현에 대한 결합보다 인터페이스에 대한 결합이 더 좋다.

  

# 02 상속으로 인한 조합의 폭발적인 증가

- 핸드폰 과금 시스템 예시
    - 기본 정책과 더불어 부가 정책이 추가되었다.
    - 부가 정책은 1) 없을수도 있고, 2) 1개가 있을수도 이고, 3) 2개가 여러 순서로 추가될 수 있다.
    - 이러한 요구사항을 상속 관계로 해결하려면, 생성 가능한 조합을 모두 상속 클래스로 만들어야 한다.

#### 추상 메서드와 훅 메서드

- 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만, 기본 구현을 제공하는 메서드를 훅 메서드라고 부른다.
    - 유연성은 유지하면서 중복 코드는 제거

  

#### 클래스 폭발

- 상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우
- 이 문제는 새로운 기능 추가할 때 뿐만 아니라, 기능을 수정할때도 문제가 된다. 여러 클래스의 관련 코드가 중복돼 있기 때문에 관련된 클래스를 모두 찾아 동일한 방식으로 수정해야 한다.

![](https://wiki.navercorp.com/download/attachments/1527531577/image-2023-7-5_8-1-24.png?version=1&modificationDate=1688511689000&api=v2 "LEE JAE HYEON[ 이재현 ] > Chapter 11 합성과 유연한 설계 > image-2023-7-5_8-1-24.png")

# 03 합성 관계로 변경하기

- 상속 관계는 컴파일 타임에 결정되고 고정되기 때문에 코드를 실행하는 도중에는 변경할 수 없다.
- 따라서 여러 기능을 조합해야 하는 설계에 상속을 이용하면 모든 조합 가능한 경우별로 클래스를 추가해야 하기 때문에 클래스 폭발이 발생한다.
- 합성 관게는 상속과 달리 런타임에 동적으로 변경할 수 있다.
- 물론, 컴파일타임 의존성과 런타임 의존성의 거리가 멀면 멀수록 설계의 복잡도가 상승하기 때문에 코드를 이해하기 어려워지는 것은 사실이다.
    - 변경에 따르는 고통이 복잡성의 혼란을 넘어선다면 유연성의 손을 들어주는 것이 현명한 판단일 확률이 높다.

  

#### 기본 정책 합성하기

- 기본 정책과 부가 정책을 포괄하는 RatePolicy 인터페이스를 만들자
- RatePolicy 기반으로 기본정책도 만들고 부가 정책도 만든다.

|   |
|---|
|public interface RatePolicy {<br>	Money calcuateFee(Phone phone);<br>}|

- 그리고 이러한 정책을 이용해 요금을 계산할 Phone을 만든다.
- Phone 내부에 RatePolicy에 대한 참조가 포함돼 있다는 것을 주목하라. 이것이 바로 합성이다.
- 런타임 의존성을 위해 생성자를 통해 RatePolicy 인스턴스에 대한 의존성을 주입받는다.
- 여기까지만 보면, 딱히 상속보다 큰 장점은 보이지 않지만, 부가 정책을 추가해보면 합성의 강력함을 알 수 있다.

|   |
|---|
|public class Phone {<br>	private RatePolicy ratePolicy;<br>	prvate List<Call> calls = new ArrayList<>();<br><br>	public Phone(RatePolicy ratePolicy) {<br>		this.ratePolicy = ratePolicy;<br>	}<br><br>	...<br>}|

  

#### 부가 정책 적용하기

- 기본 정책 요금의 인스턴스 의존성 관계는
    - Phone → RegularPolicy
- 기본 정책에 세금 부가 정책을 추가하면
    - Phone → TaxablePolicy → RegularPolicy
- 이처럼 부가 정책은 다음 2가지 제약 사항을 가진다
    - 부가 정책은 기본 혹은 다른 부가 정책의 인스턴스를 참조할 수 있어야 한다.
    - Phone 입장에서는 자신이 어떤 정책을 의존하고 있는지 몰라야 한다. (이것이 `역할`의 의미)
        - 인터페이스가 필요한 이유

|   |
|---|
|public class AdditionalRatePolicy implements RatePolicy {<br>	private RatePolicy next;<br><br>	public Phone(RatePolicy next) {<br>		this.next = next;<br>	}<br><br>	@Override<br>	public Money calculateFee(Phone phone) {<br>		Money fee = next.calculatefee(phone);<br>		return afterCalculated(fee);<br>	}<br><br>	abstract protected Money afterCalculated(Money fee);<br>}|

  

#### 기본 정책과 부가 정책 합성

- 일반 요금제에 기본 요금 할인 정책을 조합한 결과에 세금 정책을 조합하고 싶다면?

|   |
|---|
|Phone phone = new Phone(new TaxablePolicy(1, new ReatDiscountablePolicy(2, new RegualrPolicy(...)))|

  

#### 새로운 정책 추가

- 상속에서는 관련된 모든 스펙들과 합쳐진 클래스를 일일이 다 생성해서 더 큰 클래스 폭발을 일으켜야 했지만,
- 이제는 새로운 정책 클래스만 만들고, 조합에 맞게 클라이언트에서 사용하기만 하면 된다.

  

#### 객체 합성이 클래스 상속보다 더 좋은 방법이다.

- 코드를 재사용하면서도 건전한 결합도를 유지할 수 있는 더 좋은 방법은 합성을 이요하는 것이다.
- 상속은 무조건 나쁜가?
    - 상속을 구현 상속과 인터페이스 상속으로 나눠야 한다.
    - 이번 장의 단점들은 모두 구현 상속의 단점이다.
    - 인터페이스 상속은 13장에서!

# 04 믹스인

- 믹스인이란?
    - 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법
    - 코드 재사용에 특화된 방법이면서도 상속과 같은 결합도 문제를 초래하지 않는다
- 믹스인은 flavors 라는 언어에서 처음으로 도입
- 이 책에서는 스칼라 언어에서 제공하는 트레이트를 이용해 믹스인을 구현했다.

  

|   |
|---|
|trait TaxablePolicy extends BasicRatePolicy {...}|

- 이것은 상속의 개념이 아니다.
- BasicRatePolicy나 BasicRatePolicy의 자손에 해당하는 경우에만 믹스인 될 수 있다는 것을 의미한다.
    - 문맥의 제한을 의미한다.
    - 어떤 코드에 믹스인 될 것인가는 실제로 트레이트를 믹스인 하는 시점에 가서야 결정된다.
    - 즉 컴파일이 아닌, 실행 시점에 참조가 결정된다.

  

#### TaxablePolicy 믹스인한 RegularPolicy

- 믹스인된 클래스는 선형화하여 메서드 순서를 결정한다.
    - 맨앞에 자기 자신, 그 다음 트레이트를 위치시키고 그 이후 순서대로 클래스를 위치시킨다.
- TaxableregularPolicy → TaxablePolicy → RegularPolicy 구조이다.

|   |
|---|
|class TaxableregularPolicy(<br>	...<br>) extends RegularPolicy( ...)<br>with TaxablePolicy|
