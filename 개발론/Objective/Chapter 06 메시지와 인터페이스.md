객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고 받는 메시지다.

훌륭한 퍼블릭 인터페이스를 얻기 위해서는 책임 주도 설계 방법을 따르는 것만으로는 부족하다.

유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 데 도움이 되는 설계 원칙과 기법을 익히고 적용해야 한다.

# 01 협력과 메시지

  

#### 클라이언트-서버 모델

- 협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.
- 두 객체 사이의 협력 관계를 설명하기 위해 사용되는 전통적인 메타포는 클라이언트-서버 모델이다.
    - 협력 안에서 메시지를 전송하는 객체를 클라이언트
    - 메시지를 수신하는 객체를 서버라고 부른다.
- Movie 라는 객체에서 알 수 있드시 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이다.

  

#### 메시지와 메시지 전송

- 메시지 전송 : 한 객체가 다른 객체에게 도움을 요청하는 것
- 메시지는 **오퍼레이션명**과 **인자**로 구성되며, 메시지 전송은 여기에 **메시지 수산자**를 추가한 것

![](https://wiki.navercorp.com/download/attachments/1403348032/image-2023-4-25_8-1-0.png?version=1&modificationDate=1682377262000&api=v2 "LEE JAE HYEON[ 이재현 ] > Chapter 06 메시지와 인터페이스 > image-2023-4-25_8-1-0.png")

  

(인자와 파라미터의 차이는?)

  

#### 메시지와 메서드

- 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입에 달려있다.
- 이처럼 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 **메서드** 라고 부른다.
- 객체지향이 메시지 전송과 메서드 호출을 명확하게 구분한다는 사실이 모하함의 덫으로 밀어넣을 수도 있다.
    - 이렇게 실생 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.

  

#### 퍼블릭 인터페이스와 오퍼레이션

- 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다.
- 이처럼 객체가 의사소통을 위해 외부에 공개하는 메시지 집합을 **퍼블릭 인터페이스**라고 부른다.
- 프로그래밍 관점에서, 퍼블릭 인터페이스에 포함된 메시지를 **오퍼레이션** 이라고 부른다.
    - 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다.
- 메서드는 오퍼레이션에 대한 구현이다.
- 관계
    - 클라이언트 → 메시지를 전송
    - 메시지 -> (서버 퍼블릭 인터페이스) 오퍼레이션을 호출
    - 오퍼레이션 → (서버 내부) 메서드 호출

  

#### 시그니처

- 오퍼레이션의 이름과 파라미터 목록을 합쳐 시그니처 라고 부른다.
- 오퍼레이션은 실행 코드 없이 시그니처만 정의한 것이다.
- 오퍼레이션 관점에서 다형성이란. 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것

  

**객체의 퍼블릭 인터페이스가 객체의 품질을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다고 할 수 있다.**

# 02 인터페이스와 설계 품질

- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다.
    - 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다.
    - 추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.
- 최소 + 추상적인 인터페이스를 설계하는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것
- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법들
    - 디미터 법칙
    - 묻지 말고 시켜라
    - 의도를 드러내는 인터페이스
    - 명령-쿼리 분리

#### 디미터 법칙

- 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙
- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라.
    - 낯선 자에게 말하지 말라.
- 특정 조건 만족하는 대상에게만 메시지를 전송하라
    - this 객체
    - 메서드의 매개변수
    - this의 속성
    - this의 속성인 컬렉션의 요소
    - 메서드 내에세 생성된 지역 객체

##### 수정 예시

- 메서드 인자였던 Screening 인스턴스에게만 메시지를 전송한다.
    - Screening의 내부 정보는 알지 못한다.
    - 그래서 Screening 내부 정보가 변경되어도 ReservationAgency는 영향받지 않는다.

|   |
|---|
|public class ReservationAgency {<br>    public Reservation reserve(Screening screening, Customer customer, int audienceCount) {<br>        Money fee = screening.calcuateFee(audienceCount);<br>		return new Reservation(customer, screening, fee, audienceCount);<br>	}<br>}|

##### 디미터 법칙의 위반

- 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환하는 요소에 대해 연쇄적으로 메시지를 전송한다.
- 이를 **기차 충돌** 이라고 부른다.  
    - 여러 기차가 한줄로 늘어서 충돌한 것 처럼 보인다.
    - 객체.getXxx().getYyyy();

  

#### 묻지 말고 시켜라

- 디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.
- 묻지 말고 시켜라 는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어다.
- 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안된다.
- 객체의 정보를 이용하는 행동을 객체 외부가 아니라 내부에 위치시켜야 한다.
- 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라.

  

#### 의도를 드러내는 인터페이스

- 메서드 명명 2가지 방법
    - 메서드가 작업을 어떻게 수행하는지 나타내도록 이름 짓기
    -  이건 비추천이다. 왜냐면
        - 클라이언트 입장에서는 구체적으로 알 필요가 없다.
        - 메서드 수준에서 캡슐화 위반
    - '어떻게' 가 아니라 '무엇을' 하는지 드러내라. (이러한 패턴을 '의도를 드러내는 선택자' 라고 부른다.)

#####  '무엇을' 하는지 드러내라

- 어떻게 수행하는지 드러내는 이름은 메서드 내부 구현을 설명한다.
- 무엇을 하는지 드러내면, 객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다.
- 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 된다.

  

#### 합께 모으기

- 디미터 법칙은 객체 간의 협력을 설계할 때 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록 제한
- 묻지말고 시켜라 원칙은 디미터 법칙을 준수하는 협력을 만들기 위한 스타일 제시
- 의도를 드러내는 인터페이스 원칙은 객체의 퍼블릭 인터페이스에 어떤 이름이 드러나야 하는지에 대한 지침을 제공함으로써 코드의 목적을 명확하게 커뮤니케이션할 수 있게 해준다.

  

# 03 원칙의 함정

- 설계를 적절하게 트레이드 오프 할 수 있는 능력이 숙련자와 초보자의 차이

#### 디미터 법칙은 하나의 도트를 강제하는 규칙이 아니다.

- 자바8 IntStream 을 사용하면 위반이다?
    - 객체 내부 구조가 외부로 노출되지 않았다면 위반한 것이 아니다.
- 하나 이상의 도트를 사용하는 모든 케이스가 디미터 법칙 위반인 것은 아니다.
    - 객체 내부 구현에 대한 어떤 정보도 외부로 노출하지 않았다면 디미터 법칙을 준수한 것이다.

#### 결합도와 응집도 충돌

- 클래스는 하나의 변경 원인만 가져야한다.
- 디미터 법칙과 묻지말고 시켜라 원칙을 무작정 따르면 애플리케이션은 응집도가 낮은 객체로 넘쳐날 것이다.
- 가끔씩은 묻는 것 외에는 다른 방법이 존재하지 않는 경우도 존재한다.
    - 특히 컬렉션에 포함된 객체들의 처리는 객체에 물어보는 것이다.

  

# 04 명령-쿼리 분리 원칙

- 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 루틴 이라고 부른다.
- 루틴은 다시 프로시저와 함수로 구분할 수 있다.
    - **프로시저** : 내부 상태를 변경하되 값을 반환할 수 없다. → **명령**
    - **함수** : 값을 반환할 수 있지만 부수효과(내부 상태 변경)를 발생 시킬 수 없다. → **쿼리**
- 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다.
    - "질문이 답변을 수정해서는 안된다."

#### 반복 일정의 명령과 쿼리 분리하기

- 이벤트 : 특정 일자에 실제로 발생하는 사건
- 반복 일정 : 일주일 단위로 돌아오는 특정 시간 간격에 발생하는 사건 전체를 포괄적으로 지칭하는 용어
- (책에서 나온 예제에서) 버그를 찾기 어려웠던 이유
    - isSatisfied가 명령과 쿼리 2가지 역할을 동시에 수행하고 있었기 때문

#### 명령-쿼리 분리와 참조 투명성

- 참조 투명성이란?
    - x = x + 1
    - 함수는 내부에 부수효과를 포함할 경우 동일한 인자를 전달하더라도 부수효과로 의해 그 결괏값이 매번 달라질 수 있다.
    - 어떤 표현식 e가 있을때 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특정
    - 수학에서의 함수는 동일한 입력에 대해 항상 동일한 결과를 반환하므로 참조 투명성을 만족시킨다.

#### 책임에 초점을 맞춰라

- 디미터 법칙 등을 만족시키는 쉬운 방법이 있다.
- 메시지를 먼저 선택하고 그 후 메시지를 처리할 객체를 선택하는 것이다.
- 훌륭한 메시지를 얻기 위한 출발점은 책임 주도 설계 원칙을 따르는 것이다.
