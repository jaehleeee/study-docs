# 01 개방-폐쇄 원칙

- 소프트웨어 개체는 확장에 열려있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
    - 확장 : 변경을 잘 할 수 있어야 한다
    - 수정 : 기존 코드를 수정하지 않아야 한다.

#### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

- 유연하고 재사용 가능한 설계에서 런타임 의존성과 컴파일타임 의존성은 서로 다른 구조를 가진다.
- 개방-폐쇄 원칙을 수용하는 코드는 컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다.
    - OverlappedDiscountPolicy 클래스를 추가하더라고 Movie - DiscountPolicy 간의 컴파일타임 의존성은 변하지 않는다.
    - 하지만 실제 런타임때 Movie - OverlappedDiscountPolicy 인스턴스간의 협력관계가 생긴다.

#### 추상화가 핵심이다

- 개방-폐쇄 원칙의 핵심은 **추상화에 의존하는것**이다.
- 추상화
    - 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법
    - 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.
    - 추상화를 통해 생략된 부분은 확장의 여지를 남긴다.
- 올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.
- 무작정 추상화 했다고 모든 수정에 대해 설계가 폐쇄되는 것은 아니므로 변경되는 부분과 변경되지 않는 부분을 잘 구분해서 올바른 추상화를 진행해야한다.

# 02 생성 사용 분리

- 연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두 가지 책임(생성과 사용)을 서로 다른 객체로 분리해야 한다.

#### 사용과 생성을 분리하는 방법

1. 객체 생성 책임을 클라이언트로 옮기는 것
2. Factory 추가
    1. Client 역시 생성과 사용 책임을 함께 지니게 된다.
    2. 객체 생성 책임만 전담할 별도 객체인 Factory 추가

#### 순수한 가공물에게 책임 할당하기

- Factory는 도메인 모델에 속하지 않는다.
- 전체적인 결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에게 할당되어있던 객체 생성 책임을 도메인 개념과는 아무런 상관이 없는 가공의 객체(=Factory)로 이동시킨 것이다.
- 객체지향은 실세계의 모방이 아니다! 실제로는 설계자가 임의로 만든 인공적인 추상화를 포함하고 있다.
    - 좋은 설계를 위해서는 도메인 추상화로 애플리케이션 구축 시작 → 도메인 개념으로 해결하지 못하는 경우 인공적인 객체를 창조하는 것이 좋다.

# 03 의존성 주입

- 의존성 주입
    - 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법
    - 의존성을 해결하기 위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서 외부에서 필요한 런타임 의존성을 전달할 수 있도록 만드는 방법을 포괄하는 명칭

  

#### 숨겨진 의존성은 나쁘다

- 의존성 주입 외에도 의존성 해결 방법들이 있음
- Service Locator 패턴 : 의존성을 해결할 객체들을 보관하는 일종의 저장소
    - 객체가 직접 Service Locator에게 의존성을 해결해 줄 것을 요청한다.
    - Service Locator 패턴의 단점 : 의존성을 감춘다.
    - Service Locator 패턴의 단점2 : 단위테스트도 어렵다. ServiceLocator의 상태가 모든 단위 테스트에 공유되어야하기 때문에 단위 테스트는 서로 고립돼야한다는 원칙에 위배된다.
    - Service Locator 패턴의 가장 큰 문제점 : 의존성을 이해하기 위해 코드의 내부 구현을 이해할 것을 가용한다. 따라서 숨겨진 의존성이 캡슐화를 위반한다.

- **명시적인 의존성(ex. 의존성 주입)이 숨겨진 의존성보다 좋다.**

# 04 의존성 역전 원칙

#### 추상화와 의존성 역전

- Movie-AmountDiscountPolicy 사이의 협력의 본질은 영화의 가격을 계산하는거지 어떻게 할인 금액을 계산할 것인지가 아니다.
- 이렇게 상위 수준 클래스가 하위 수준의 클래스에 의존한다면 하위 수준의 변경에 의해 상위 수준 클래스가 영향을 받게된다.
    - 문제점 1: 할인 정책으로 인해 Movie가 변경되면서 변경이 많이 전파된다.
    - 문제점 2: 상위 클래스를 재사용할 때 하위 클래스도 필요하기 때문에 재사용하기가 어려워진다.
- 해결방법 : DiscountPolicy를 이용한 추상화
- **의존성 역전 원칙** (Dependency Inversion Principle)
    - 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야한다.
    - 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야한다.

#### 의존성 역전 원칙과 패키지

- ㅇㅇ

  

# 유연성에 대한 조언

#### 유연한 설계는 유연성이 필요할 때만 옳다

- 유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다. 단순하고 명확한 설계가 만족 스럽다면 유연성을 제거해라.

#### 협력과 책임이 중요하다.

- 중요한 비즈니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것보다 우선이다.
