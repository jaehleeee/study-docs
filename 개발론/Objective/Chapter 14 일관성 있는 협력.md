- 객체는 협력을 위해 존재한다.
- 객체지향 패러다임의 장점은 설계를 재사용할 수 있다는 것이다.
    - 재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 한다.
- 가능한 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용하라.
    - 일관성 있는 협력 패턴을 적용하면 여러분의 코드가 이해하기 쉽고 직관적이며 유연해진다는 것이 이번 장의 주제다.

# 01 핸드폰 과금 시스템 변경하기

- 기본 정책의 확장
    - 고정요금 방식 : 초당 10원
    - 시간대별 방식 : 19시까진 초당 20원, 19시부터 24시까진 초당 15원
    - 요일별 방식 : 평일은 초당 20원, 공휴일은 초당 10원
    - 구간별 방식 : 처음 1분간 초당 10원, 이후 초당 20원
- 이러한 정책들을 각각 일관성을 생각하지 않고 구현한다면?

#### 시간대별 방식

- 작업 구분
    - 통화 기간을 일자별로 분리한다.
    - 일자별로 분된 기간을 다시 시간대별 규칙에 따라 분리한 후 각 기간에 대해 요금을 계산한다.
- 각 작업을 각 작업의 전문가 객체의 책임으로 할당.

#### 요일별 방식

- 요일의 목록, 단위 시간, 단위 요금 이라는 3가지를 요소를 이용한 규칙 구현
- 작업 구분
    - 통화 기간을 날짜 경계로 분리한다.
    - 날짜 경계별 규칙에 따라 요금을 계산한다.

#### 구간별 방식

- 새로운 규칙 클래스 생성
- 작업 구분
    - 통화 기간을 구간 기준으로 분리한다.
    - 구간별 규칙에 따라 요금을 계산한다.

#### 3가지 방식을 구현하고 보니 일관성이 없다.

- 비일관성은 2가지 상황에서 발목을 잡는다.
    - 새로운 구현을 추가해야하는 상황
    - 기존 구현을 이해해야 하는 상황
        - 대부분의 사람들은 유사한 요구사항을 구현한 코드는 유사한 방식으로 구현할거라 예상하기 때문
        - 구현이 다르면 유사한 요구사항이 유사하지 않다고 오해할 수 있다.
- 결론은 유사한 기능을 서로 다른 방식으로 구현해서는 안된다는 것이다.

# 02 설계에 일관성 부여하기

- 일관성있는 설계를 위한 조언
    - 다양한 설계 경험을 익히라
    - 널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥안에서 적용해보라.
- 협력을 일관성 있게 만들기 위해서는?
    - 변하는 개념을 변하지 않는 개념과 분리하라.
    - 변하는 개념을 캡슐화 하라.

#### 조건 로직 vs 객체 탐색

- 절차지향에서는 조건 로직을 이용해 할인 조건과 정책을 결정했다.

|   |
|---|
|switch(movie.getMovieType()) {<br>	case 금액할인:<br>		...<br> 	case 비율할인:<br>		... <br> 	case 할인정책없음:<br>		...|

  

- 객체지향에서는 조건 조릭을 객체 사이의 이동으로 바꾼다.
- 다형성은 바로 이런 조건 로직을 객체 사이의 이동을 봐꾸기 위해 객체지향이 제공하는 설계 기법이다.
    - Movie는 discountPolicy가 자신의 요청을 잘 처리해줄 것이라고 믿고 메시지를 전송할 뿐이다.

#### 일관성 있는 협력을 위한 지침

1. 변하는 개념을 변하지 않는 개념으로부터 분리하라.
2. 변하는 개념을 캡슐화하라.

#### 캡슐화 다시 살펴보기

- 사람들은 흔히 캡슐화를 데이터 은닉이라고 생각한다.
- 하지만 캡슐화는 데이터 은닉 그 이상이다.
- 캡슐화란 변하는 어떤 것이든 감추는 것이다.
- 가장 대표적인 예시는 객체의 퍼블릭 인터페이스와 구현을 분리하는 것이다.
- 다양한 종류의 캡슐화가 있다.
    - 데이터 캡슐화 - private 필드
    - 메서드 캡슐화 - private, protected 메서드
    - 객체 캡슐화 - 합성을 의미
    - 서브타입 캡슐화 - 다형성
- 협력을 일관성있게 만들려면 서브타입 캡슐화(인터페이스 상속)와 객체 캡슐화(상속)를 조합하는 것이다.

# 03 일관성 있는 기본 정책 구현하기

#### 변경 분리하기

- 요금제들의 공통점(변하지 않는 부분) 찾기
    - 기본 정책은 1개 이상의 '규칙'으로 구성된다.
    - 하나의 규칙은 '적용조건'과 '단위 요금'의 조합이다.

![](https://wiki.navercorp.com/download/attachments/1683023023/image-2023-8-30_20-1-51.png?version=1&modificationDate=1693393313000&api=v2 "LEE JAE HYEON[ 이재현 ] > Chapter 14 일관성 있는 협력 > image-2023-8-30_20-1-51.png")

- 변하지 않는 것은 규칙이고, 변하는 것은 적용 조건이다.

#### 변경 캡슐화하기

- 변하지 않는 것에서 변하는 것을 분리해야 한다.
- 규칙으로 부터 적용조건을 분리해서 추상화한 후 시간대별, 요일별, 구간별 방식을 이 추상화의 서브타입으로 만든다.
    - 이것이 서브타입 캡슐화다.
- 그 후 규칙이 적용조건을 표현하는 추상화를 합성 관계로 연결한다.
    - 이것이 객체 캡슐화다.

![](https://wiki.navercorp.com/download/attachments/1683023023/image-2023-8-30_20-4-53.png?version=1&modificationDate=1693393494000&api=v2 "LEE JAE HYEON[ 이재현 ] > Chapter 14 일관성 있는 협력 > image-2023-8-30_20-4-53.png")

#### 협력 패턴 설계하기

- 변하는 부분과 변하지 않는 부분을 분리하고 나면 변하는 부분은 생략한 채 변하지 않는 부분만을 이용해 객체 사이의 협력을 이야기 할 수 있다.
- 하나의 Call 작업을 계산하기 위해서는 2개의 작업이 필요하다.
    1. 전체 통화 시간을 각 '규칙'의 '적용조건'을 만족하는 구간들로 나누는 것이다.
    2. 이렇게 분리된 통화 구간에 단위요금을 적용해서 요금을 계산하는 것이다.
- 각 책임은 각 작업을 가장 잘 아는 정보 전문가인 FeeCondition과 FeeRule이 담당하는 것이 적절하다.
- 이렇게 설계한 구조가 잘 작동할까?
    - 직접 구현해보는 방법 뿐이다.

#### 협력 구현하기

- 일관성 있는 협력을 이해하고 나면 변하는 부분만 따로 떼어내어 독립적으로 이해하더라도 전체적인 구조를 쉽게 이해할 수 있다.
- 유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 객체지향 시스템에서 개념적 무결성 을 유지할 수 있는 가장 효과적인 방법이다.
- 개념적 무결성을 일관성과 동일한 뜻으로 간주해도 무방하다.

#### 협력 패턴에 맞추기

- 이제 고정요금 규칙이 남았다.
- 고정요금 규칙은 단위요금 정보만 필요하다.
- 그러나 기존 협력 패턴에 맞추는 것이 가장 좋기 때문에, 적용조건 분리없이 그대로 전달해준다.
- 개념적으로 불필요한 부분이 추가되지만, 개념적 무결성을 무너뜨리는 것 보다는 약간의 부조화를 수용하는 편이 더 낫다.

#### 지속적으로 개선하라

- 처음 일관성을 유지하는 것처럼 보이던 협력 패턴이 시간이 흐르고 새로운 요구사항이 추가되면서 일관성에 조금씩 금이 간다.
- 만약 현재 협력 패턴으로 변경의 무게를 지탱하기 어렵다면 변경을 수용할 수 있는 협력 패턴을 향해 과감하게 리팩터링 하라.

#### 패턴을 찾아라.

- 애플리케이션에서 유사한 기능에 대한 변경이 지속적으로 발생하고 있다면 변경을 캡슐화 할 수 있는 적절한 추상화를 찾은 후, 이 추상화에 변하지 않는 공통적인 책임을 할당하라.
