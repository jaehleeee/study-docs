# 들어가며

## 패러다임의 시대

- 패러다임의 의미
    - 패러다임이라는 말은 '모델', '패턴' 또는 '전형적인 예'를 의미하는 '파라데이그마' 라는 단어에서 유래
    - 과거에는 표준적인 모델을 따르거나 모방하는 상황을 가리키는 매우 제한적인 상황에서만 패러다임이라는 단어를 사용
    - 현대인들은, '한 시대의 사회 전체가 공유하는 이론이나 방법, 문제의식 등의 체계'를 의미
- 의미가 변화된 이유
    - 과학혁명이란, 과거의 패러다임이 새로운 패러다임에 의해 대체됨으로써 정상과학의 방향과 성격이 변하는 것을 의미 → '패러다임 전환' 이라고 부른다.
    - 프로그래밍에서의 패러다임 전환은 절차형 → 객체지향으로 변화를 의미한다.

  

## 프로그래밍 패러다임

- 프로그래밍 패러다임이라는 용어는 '로버트 플로이드'가 처음 사용
- 우리가 어떤 프로그래밍 패러다임을 사용하느냐에 따라 우리가 해결할 문제를 바라보는 방식과 프로그램 작성 방법이 달라진다.
- 패러다임이 중요한 이유는?
    - 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지한다.
- 이 책의 목표 : 객체지향 패러다임이라는 용어를 사용할때 어느 정도 유사한 그림을 머릿속에 그릴 수 있는 기반 제공
- 과학혁명에서 말하는 패러다임과 프로그래밍 패러다임의 차이점
    - 과학혁명 : 2가지 패러다임이 함께 존재할 수 없다. / 혁명적이다
    - 프로그래밍 : 2가지 패러다임이 함께 존재할 수 없는 것은 아니다. 오히려 서로가 공존함으로써 서로의 장단점을 보완하는 경향이 있다. / 발전적이다.

  

# Chapter 1. 객체, 설계

- 이론이 먼저일까, 실무가 먼저일까
- 어떤 분야를 막론하고 이론을 정립할 수 없는 초기에는 실무가 먼저다.

## 01 티켓 판매 애플리케이션 구현하기

- 일단 동작만 제대로 하는 애플리케이션을 구현하자.

## 02 무엇이 문제인가

로버트 마틴이 말하길, 모든 소프트웨어 모듈에는 3가지 목적이 있다.

1. **실행 중 제대로 동작해야 한다.**
2. **변경 용이해야 한다.**
3. **코드 이해가 쉬워야 한다.**

아까 짠 코드는 1은 만족하지만, 2,3은 만족하지 않는다.

왜냐?

 → TicketSeller와 Audience는 각각 능동적으로 행동할 수 있는 객체인데, 위 코드에서는 둘다 극장의 통제를 받는 수동적인 존재로 만들어져 있기 때문.

이해 가능한 코드란?

→ 그 동작이 우리의 예상에서  크게 벗어나지 않는 코드여야 한다.

→ 그런데 위 코드는 이러한 상식을 벗어나는 동작을 보이기 때문에 사람과 제대로 의사소통하지 못한다.

  

![](https://wiki.navercorp.com/download/attachments/1351422872/image-2023-3-15_21-7-3.png?version=1&modificationDate=1678914428000&api=v2 "LEE JAE HYEON[ 이재현 ] > Chapter 01 객체, 설계 > image-2023-3-15_21-7-3.png")

  

##### 변경에 취약한 코드

- 코드 이해가 어려운 2번째 이유는 '변경에 취약'하다는 점 때문이다.
- 예를 들면, 관람객의 가방이 변경되면 극장에서 접근하는 메서드도 수정이 필요하다.
    - 이 처럼 세부적으로 알고 있는 (의존하는) 정보가 서로 많이 엮여있을 수록 변경이 어려워진다.
    - 이를 객체 사이의 의존성(dependency) 라고 한다.
- 우리의 목표는, 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이다.
- 객체 사이의 의존성이 과한 경우를 가리켜 결합도(coupling)가 높다고 말한다.

## 03 설계 개선하기

- 변경과 의사소통이라는 문제는 서로 엮여있다.
- 극장은 관람객과 판매원과 너무 많이 결합되어 있다.
- 해결은 간단하다.
    - 극장에서는 관람객과 판매원의 정보 중 너무 세세한 것 까지 알지 못하도록 차단하면 된다.
    - 관람객과 판매원을 자율적인 존재로 만들면 된다.
- 이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사향을 감추는 것을 캡슐화 라고 부른다.
- 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다.
- 객체를 인터페이스와 구현으로 나누고, 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.

  

![](https://wiki.navercorp.com/download/attachments/1351422872/image-2023-3-16_10-55-16.png?version=1&modificationDate=1678964124000&api=v2 "LEE JAE HYEON[ 이재현 ] > Chapter 01 객체, 설계 > image-2023-3-16_10-55-16.png")

극장에서는 관람객과 판매원 의존성이 사라졌다.

  

  

![](https://wiki.navercorp.com/download/attachments/1351422872/image-2023-3-16_10-56-24.png?version=1&modificationDate=1678964188000&api=v2 "LEE JAE HYEON[ 이재현 ] > Chapter 01 객체, 설계 > image-2023-3-16_10-56-24.png")

판매원과 관람객 가방 사이의 의존성 제거

  

#### 어떻게 한 것인가

- 티켓 판매관련은 TiketSeller 내부로, 관람객 가방 관련 부분은 관람객 내부로 옮김.
- 자기 자신의 문제를 스스로 해결하도록 코드를 변경한 것

#### 캡슐화와 응집도

- 밀접하게 연관된 작업만을 수행하고, 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다.

#### 절차지향과 객체지향

- 극장은 enter 메서드라는 프로세스 안에서 관람객과 판매원의 가방과 매표소라는 데이터를 가져와 관람색을 입장 시킨다.
- 이러한 방식을 절차적 프로그래밍이라고 한다.
- 반대로, 자신의 데이터는 스스로 처리하도록 프로세스를 적절한 단계로 이동시키는 방식, 즉 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 객체지향 프로그래밍이라고 한다.

#### 책임의 이동

- 위 두 방식 사이의 근본적 차이는 책임의 이동이다.
- '책임' 을 기능을 가리키는 객체지향 세계의 용어로 봐도 무방
- 절자지향에서는 책임이 '극장'에 몰려있었다면
- 객체지향에서는 책임이 개별 객체로 이동한 것이다.
- 설계를 어렵게 만드는 것은 의존성이다.
    - **해결은 의존성을 제거하여 객체사이의 결합도를 낮추는 것이다.**
    - **겹합도를 낮추는 방법은 세부사항들을 각 객체 내부로 감춰 캡슐화하는 것이다.**
    - **결과적으로 자율성을 객체의 높이고, 응집도 높은 객체들의 공동체를 창조할 수 있다.**

  

#### 더 개선할 수 있다

- 관람객이 가지고 있던 가방의 자율성과 판매원이 가지고 있던 매표소의 자율성을 찾아주자.
- 그러다보니 매표소에서 관람객 사이의 의존성이 추가되었다.
- 현재로서는 관람객의 결합도와 매표소의 자율성 모두를 만족시킬 수는 없다.
- 결국 설계는 트레이드오프의 산물이다.

  

#### 그래, 거짓말이다

- 실세계에서 관람객와 판매자는 원래 능동적인 객체이다.
- 그러나 극장, 가방 등은 수동적인 존재이다. 하지만
- 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.
- 이를 의인화 라고 부른다.

> 객체 이름을 능동적으로 짓는 것도 중요할 것 같다. 가방보다는 물건제공자? ... 이름을 이렇게 짓지 않더라도 이렇게 이해만 하더라도 도움이 될듯

> 그래서 라이브러리 같은데서 객체 이름이 Provider 거나 Factory 혹은 Resolver 처럼 능동적인 이름을 쓰는 것 같다!

## 04 객체지향 설계

#### 설계가 왜 필요한가

- 설계의 정의 중 저자가 가장 좋아하는 정의 '설계란 코드를 배치하는 것이다.'
- 설계는 코드 작성의 일부이며 코드를 작성하지 않고서는 검증할 수 없다.
- 좋은 설계란? 2가지 요구사항 만족해야 한다.
    - 오늘 완성해야 하는 기능을 구현하는 코드
    - 내일 쉽게 변경할 수 있는 코드
- 변경을 수용할 수 있는 설계가 중요한 이유는?
    - 요구사항이 항상 변경되기 때문
    - 코드를 변경할 때 버그가 추가될 가능성이 높기 때문.

> 테스트 코드도 중요할 것으로 보임. TDD 스터디가 생각남.

  

#### 객체지향 설계

- 우리가 진정으로 원하는 것은 변경에 유연하게 대응할 수 있는 코드다.
- 단순히 데이터와 프로세스를 객체라는 덩어리 안으로 밀어 넣었다고 해서 변경하기 쉬운 설계를 얻을 수 있는 것은 아니다.
- 훌량한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다.
