데이터 중심 설계로 인해 발생하는 문제점을 해결할 수 있는 가장 기본적인 방법은 데이터가 아닌 책임에 초점을 맞추는 것

책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 어떤 객체에게 어떤 책임을 할당할지를 결정하기가 쉽지 않다는 것

# 01 책임 주도 설계를 향해

- 책임주도 설계를 위한 2가지 원칙
    - 데이터보다 행동을 먼저 결정하라
    - 협력이라는 문맥 안에서 책임을 결정하라

  

#### 데이터보다 행동을 먼저 결정하라

- 클라이언트 관점에서 객체가 수행하는 행동 == 객체의 책임
- 우리에게 필요한 것은?  
    : 객체의 데이터에서 책임으로 무게중심을 옮기는 것
- 가장 기본적인 해결 방법은, 객체를 설계하기 위한 질문의 순서를 바꾸는 것
    - 데이터 중심 : "이 객체가  포함해야하는 데이터가 무엇인가? → 오퍼레이션은 무엇인가?"
    - 책임 중심 : "객체가 수행해야 하는 책임은 무엇인가? → 필요한 데이터는 무엇인가?"
- 객체지향 설계에서 가장 중요한 것은 적절한 객체엑 적절한 책임을 할당하는 능력
    - 책임 할당은 어떻게?
    - 실마리는 협력에 있다.

  

#### 협력이라는 문맥 안에서 책임을 결정하라

- 객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정된다.
    - 객체의 입장에서 책임이 어색하더라도 협력에 적합하다면 그 책임은 좋은 것이다.
- 협력에 적합한 책임이란?  
    : 메시지 수신자가 아니라 메시지 전송자에게 적합한 책임이다. 즉 클라이언트 의도에 적합한 책임
- 협력에 적합한 책임을 수확하기 위해서는 객체를 결정한 후 메시지 선택이 아니라, 메시지를 결정한 후 객체를 선택해야 한다.
    - "이 클래스가 필요한건 알겠는데 이 클래스로 뭘해야하지?" 라는 질문이 아니라 → "메시지를 전송해야 하는데 누구에게 전송하지?" 라고 질문해야 한다.
- 메시지를 먼저 결정하므로 메신지 발신자는 수신자에 대한 어떠한 가정도 할 수 없다. → 메시지 수신자가 깔끔하게 캡슐화된다.

  

##### 책임 주도 설계

- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우, 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

# 02 책임 할당을 위한 GRASP 패턴

- GRASP : General Responsibility Assignment Software Pattern

이제 영화 예매 시스템을 책임 중심으로 설계하는 과정을 따라가보자.

#### 도메인 개념에서 출발하기

- 어떤 책임을 할당해야할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념이다.
- 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요가 없다.

  

![](https://wiki.navercorp.com/download/attachments/1403330774/image-2023-4-18_7-9-52.png?version=1&modificationDate=1681769395000&api=v2 "LEE JAE HYEON[ 이재현 ] > Chapter 05 책임 할당하기 > image-2023-4-18_7-9-52.png")

  

#### 정보 전문가에게 책임을 할당하라

- 책임주도 설계 첫단계  
     : 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로서 생각하는 것.
    - 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고 이 메시지를 책임질 첫 번째 객체를 선택하는 것으로 설계를 시작한다.
    - 사용자에게 제공해야할 기능은 영화를 예매하는 것

` 메시지를 전송할 객체는 무엇을 원하는가? ` : ` 예매하라. `

` 메시지를 수신할 적합한 객체는 누구인가? ` : ` Screening `

- 객체에게 책임을 할당하는 첫번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것
- 이를 INFORMATION EXPERT 패턴이라고 부른다.
    - 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라.
    - 정보와 행동을 최대한 가까운 곳에 위치시키기 때문에 캡슐화를 유지할 수 있다.
- 여기서 말하는 정보는 데이터와 다르다.
    - 책임을 수행하는 객체가 정보를 알고 있다고 해서 그 정보를 저장하고 있을 필요는 없다.

` 가격을 계산하라 ` → ` Movie `

- 예매하라는 메시지를 수신받고 나서의 흐름을 생각해보자.
- 무엇이 필요한가? 가격 계산이 필요하다.
- Screening은 가격 계산에 필요한 정보를 모르기 때문에 정보 전문가가 필요하다.

` 할인 여부를 판단하라 ` → `  Discount Condition `

- Movie가 가격 계산 메시지를 받고 나서는 어떤 영화가 할인 가능할지 판단 후 가격을 계산해야 한다.
- 여기서 할인 여부를 판단하라는 메시지를 전문가에게 맡겨야 한다.

`  DiscountCondition `

- DiscountCondition 객체는 할인 여부를 판단하는 정보를 모두 알고 있기 때문에 외부 도움 없이 스스로 판단할 수 있다.

  

#### 높은 응집도와 낮은 결합도

- 다양한 설계가 나올 수 있고, 설계는 트레이드 오프다.
- 위 설계와는 다르게, Screening이 할인여부를 직접 협력하는 케이스를 고려해보자.

  

![](https://wiki.navercorp.com/download/attachments/1403330774/image-2023-4-18_7-32-37.png?version=1&modificationDate=1681770759000&api=v2 "LEE JAE HYEON[ 이재현 ] > Chapter 05 책임 할당하기 > image-2023-4-18_7-32-37.png")

- 왜 우리는 이 설계 대신 위에서 했던 설계를 선택했을까?
- 여러 설계 중 올바르게 책임을 할당할 때 필요한 패턴들이 있다.
- LOW COUPLING (낮은 결합도) 패턴
    - 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라.
    - 도메인 개념으로 보면, Movie는 이미 DiscountCondition과 결합돼있다.
    - 그래서 Movie와 DiscountCondition이 협력한다면 추가 결합 없이 협력을 완성할 수 있다.
- HIGH COHESION (높은 응집도) 패턴
    - 높은 응집도를 유지할 수 있게 책임을 할당하라.
    - Screening의 가장 중요한 책임은 영화 예매이다.
    - 여기서 할인 조건 관련 책임까지 맡게 된다면
        - DiscountCondition가 할인 여부를 판단한다는 사실과
        - Movie가 할인 여부 판단 정보를 필요로 한다는 사실까지 알고 있어야 한다.
        - 즉, 영화 요금 계산 방식이 변경될 경우 Screening도 함께 변경해야 한다.
        - 서로 다른 이유로 변경되는 책임을 짊어지게 되므로 응집도가 낮아질 수 밖에 없다.

#### 창조자에게 객체 생성 책임을 할당하라

- 객체를 생성해야 할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가?
    - CREATOR 패턴
    - 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에게 책임을 맡긴다.

  

##### 대략적으로 책임 할당이 완료되었다면?

협력과 책임이 제대로 동작하는지 확인할 수 있는 유일한 방법은 코드를 작성하고 실행해보는 것 뿐이다.

# 03 구현을 통한 검증

#### DiscountCondition 개선하기

-  DiscountCondition은 변경에 취약하다는 단점이 있다.
- 서로 다른 3가지 이유로 변경될 수 있다
    - 새로운 할인 조건 추가
    - 순번 조건을 판단하는 로직 변경
    - 기간 조건을 판단하는 로직이 변경되는 경우
- 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮다.
- 응집도가 낮다는 의미  
     : 연관성이 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져 있다
- 따라서 변경의 이유에 따라 클래스를 분리해야 한다
- (이처럼 설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하는 것이 좋다.)
    - 변경 이유를 파악하는 방법 2가지
        - 인스턴스 변수가 초기화되는 시점 살펴보기
            - 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.
            - 반면 응집도가 낮은 클래스는 객체 속성 중 일부만 초기화하고 일부는 초기화되지 않은 상태로 남겨진다.
            - 즉 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.
        - 메서드들이 인스턴스 변수를 사용하는 방식 살펴보기
            - 모든 메서드가 객체의 모든 속성을 사용한다? 응집도 높음
            - 메서드들이 사용하는 속성에 따라 그룹이 나뉜다? 응집도 낮음
            - 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.

#### 타입 분리하기

- 첫 해결책 : 타입을 2개의 클래스로 분리하기 (SequenceCondition, PeriodCondition)
    - 인스턴스 초기화나 사용하는 속성이 동일해졌기 때문에 개별 클래스들의 응집도가 향상됐다.
- 하지만 Movie의 입장에선 협력해야 하는 클래스가 늘어났다. → 결합도 증가
    - 그 문제는 Movie 안에 SequenceCondition, PeriodCondition 2개의 목록을 따로 유지하는 방법으로 해결  가능하지만,
    - 새로운 할인 조건이 생길때마다 Movie에 리스트를 추가해야한다는 단점이 생겼다.

#### 다형성을 통해 분리하기

- 사실 Movie 입장에서는  SequenceCondition든, PeriodCondition든 별 차이 없다. 둘다 할인 여부 판단하는 책임을 수행할 뿐이다.
- 이때 역할 개념이 등장한다.
- Movie가 구체적인 클래스는 알지 못한 채 오직 역할에 대해서만 결합되도록 의존성을 제한할 수 있다.
- java 에서는 추상클래스나 인터페이스를 일반적으로 역할 구현에 사용한다.
    - 공통으로 구현을 공유할 필요에 따라 나뉨

POLYMORPHISM(다형성) 패턴

- 객체의 암시적인 타입에 따라 행동을 분기해야 한다면 암시적인 타입을 명시적인 클래스로 정의하고
- 행동을 나눔으로써 응집도 문제를 해결할 수 있다.
- 객체의 타입에 다라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라.

#### 변경으로부터 보호하기

- SequenceCondition과 PeriodCondition 두 서브클래스는 서로 다른 이유로 변경된다.
- 2개의 서로 다른 변경이 2개의 서로다른 클래스 안으로 캡슐화된다.
- 새로운 할인 조건이 추가되어도, Moive는 영향 받지 않는다.
- 이처럼 변경을 캡슐화호도록 책임을 할당하는 것을  PROTECED VARIATIONS(변경 보호) 패턴 이라고 부른다.
    - 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라.
    - 설계에서 변하는 개념을 캡슐화하라.

정리

- 하나의 클래스가 여러 타입의 행동을 구현하고 있는 것처럼 보인다면? POLYMORPHISM(다형성) 패턴 → 책임을 분산하라.
- 예측 가능한 변경으로 인해 여러 클래스들이 불안정해진다면? PROTECED VARIATIONS(변경 보호) 패턴 → 인터페이스 뒤로 변경을 캡슐화하라.

  

#### Movie 클래스 개선하기

- 금액 할인 정책 영화, 비율 할인 정책 영화 2가지 타입을 하나의 클래스 안에 구현하므로, 하나 이상의 이유로 변경될 수 있다. → 응집도가 낮다.
- 해결 방법은 POLYMORPHISM(다형성) 패턴

#### 변경과 유연성

- 변경에 대비하는 방법은 2가지다
    - 코드를 이해하고 수정하기 쉽게 설계
    - 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것 (이 방법이 더 좋음)

영화의 경우, 설정된 할인 정책이 실행중 변경할 수 있어야 한다는 요구사항이 추가되었다고 가정해보자.

- 할인 정책 구현에 상속을 이용하고 있기 때문에 새로운 인스턴스를 생성할 후 필요한 정보를 복사해야 한다.
- 새로운 정책이 추가될때마다 인스턴스를 생성하고 상태를 복사하고 식별자를 관리하는 코드를 추가하는 일은 번거로울뿐만 아니라 오류가 발생하기도 쉽다.
- 해결방법은 합성을 사용하는 것
- Movie의 상속 계층 안에 구현된 할인 정책을 독립적인 DiscountPolicy로 분리 후 Movie에 합성시키면 유연한 설계 완성

  

이번 장을 읽어도 책임 할당이 어렵다면?

일단 절차형 코드로 실행되는 프로그램을 빠르게 작성한 후 완성된 코드를 객체지향적인 코드로 변경해보자.

# 04 책임 주도 설계의 대안

- 책임과 객체 사이에서 방황할 때 돌파구를 찾기 위해 선택하는 방법은 최대한 빠르게 목적한 기능 코드 작성 후 명확하게 드러난 책임들을 올바른 위치로 이동시키는 것
- 주의할 점
    - 동작이 바뀌어서는 안된다.
    - 캡슐화 향상, 응집도 높이고 결합도를 낮춰야 하지만 동작은 유지해야한다.
- 이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것을 리팩터링이라고 부른다.

#### 메서드 응집도

- 데이터 중심 설계에서는 ReservationAgency에 책임이 집중되어 있었다.
- 이 책임들을 잘 분배하면 책임 중심 설계와 유사한 결과를 얻을 수 있다.
- 긴 메서드는 다양한 측면에서 코드 유지보수에 부정적인 영향을 미친다.
    - 한눈에 파악이 어렵다
    - 변경이 필요할 때 수정이 필요한 부분 찾기힘들다
    - 메서드 일부 수정하더라도 나머지 부분에서 버그 발생할 수도 있다.
    - 로직의 일부만 재사용하는 것이 불가능하다
    - 코드를 재사용하는 유일한 방법은 코드 복붙 뿐이니 중복 초래하기 쉽다.
- 이러한 메서드를 몬스터 메서드라고 한다.
- 응집도 높은 메서드는 변경 이유가 단 하나여야 한다.
- 짧고 이해하기 쉬운 이름으로된 메서드가 좋은 이유
    - 재사용될 수 있다.
    - 고수준의 메서드를 볼떄 일련의 주석을 읽는 느낌이 든다.
    - 오버라이딩이 쉽다.
- 객체로 책임을 분배할 때 가장 먼저 할 일은 메서드를 응집도 있는 수준으로 분해하는 것. → 메서드를 적절한 클래스로 분배하기 쉬워진다.

  

#### 객체를 자율적으로 만들자

- 어떤 메서드를 이동시켜야 할까?
- 자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 하는 것이 자율적인 객체를 만드는 지름길
- 메서드 안에서 어떤 클래스의 접근자 메서드(getter 인듯)를 사용하는지 파악하는 것이 어떤 데이터를 사용하는지 아는 가장 쉬운 방법
    - 해당 클래스로 이동시는게 좋다. 그럼 접근자 메서드를 제거할 수 있다.
