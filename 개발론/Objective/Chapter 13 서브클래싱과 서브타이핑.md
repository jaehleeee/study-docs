- 상속의 용도
    - **타입 계층을 구현(상속의 1차적인 목표)**
        - 부모 클래스: 자식 클래스의 일반화(generalization)
        - 자식 클래스: 부모 클래스의 특수화(specialization)
    - 코드 재사용  
        - 단순히 코드 재사용을 위한 상속은 피할 것
- 타입 사이의 관계를 고려하지 않은 채 단순히 코드를 재사용하기 위해 상속을 사용해서는 안 된다.

# 01 타입

#### 개념 관점의 타입

- **타입**은 사물을 분류하기 위한 틀
    - 심볼(명칭), 내연(속성), 외연(집합)
- 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 **인스턴스**라고 부름
- 타입의 인스턴스를 **객체**라고 부름

#### 프로그래밍 언어 관점의 타입

- 프로그래밍 내에서 타입은 연속적인 비트에 의미와 제약을 부여하기 위해 사용
- 프로그래밍 언어에서 타입의 두가지 목적
    1. 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다
        - ex) +을 사용할 수 있는 집합(string, 숫자)이 있고, 사용하지 못하게 제한되는 타입이 있다.
    2. 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다
        - ex) +을 사용하면 나오는 결과: concat, 덧셈 등 약속된 문맥이 타입에 따라 다르다.

#### 객체지향 패러다임 관점의 타입

- 타입의 정의 정리
    - 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류다
        - 공통의 특징 = 퍼블릭 인터페이스
    - 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다.
        - 오퍼레이션: 객체가 수신할 수 있는 메시지 의미
        - 객체의 타입이란 객체가 수신할 수 있는 메세지의 종류를 정의하는 것 → **퍼블릭 인터페이스**
        - 타입 정의 = 퍼블릭 인터페이스 정의

# 02 타입 계층

- 입을 일반화와 특수화 관계를 가진 계층으로 표현 → 타입 계층
    - 더 일반적인 타입 = 수퍼 타입
    - 더 특수한 타입 = 서브타입
- 내연과 외연 관점에서 살펴보기
    - 내연(속성)
        - 일반화: 보편적, 추상적
        - 특수화: 구체적, 문맥 종속적
    - 외연(집합)
        - 일반화: 슈퍼셋
        - 특수화: 서브셋
- 일반화는 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과
- 특수화는 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과
- 슈퍼타입과 서브타입 관점으로 보기
    - 슈퍼타입
        - 내연: 타입 정의가 일반적
        - 외연: 다른 집합을 포함함
    - 서브타입
        - 내연: 타입 정의가 구체적
        - 외연: 다른 집합에 포함됨.

서브 타입의 인스턴스는 슈퍼 타입의 인스턴스로 간주될 수 있다.

# 03 서브클래싱과 서브타이핑

#### 언제 상속을 해야하는가?

- 마틴 오더스키가 말하길 두가지 조건을 만족해야한다.
    1. is-a 관계
    2. 부모 클래스의 타입으로 자식 클래스를 사용해도 무방해야함

#### is-a 관계

- 스콧 마이어스가 is-a가 직관과 다르다는 것을 펭귄으로 설명해줌
    - 펭귄 = 새 (실제 조류계열로 분류함..)
    - 새 = 날 수 있다
    - 팽귄 != 날수 있다
- 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.
- 따라서 어떤 두 대상이  is-a 라고 표현할 수 있더라도 일단은 상속의 사용할 예비 후보 정도로만 판단하자.

#### 행동 호환성

- 행동의 호환 여부를 판단하는 기준은 클라이언트 관점

#### 클라이언트의 기대에 따라 계층 분리하기

- 행동 호환성을 만족시키지 않는 상속 계층을 그대로 유지한 채 클라이언트의 기대를 충족시킬 수 있는 방법을 찾기란 쉽지 않다.
- 문제를 해결할 수 있는 방법은 클라이언의 기대에 맞게 상속 계층을 분리하는 것 뿐이다.

#### 서브클래싱과 서브타이핑

- 어떻게 상속을 판단할 것인가? 2가지 목적을 기억
    1. 서브클래싱 : 코드 재사용
    2. 서브타이핑 : 타입 계층 구성 
- 이 둘을 나누는 기준은 상속을 사용하는 목적이다.
- 서브클래싱: 다른 클래스의 코드를 재사용할 목적
- 서브타이핑: 타입 계층을 구성하기 위해 상속을 사용하는 경우
    - 유지하기 위해 행동 호환성을 만족시켜야함.
        - 대체 가능성: 행동호환성을 만족하는 상속관계는 부모 클래스를 새로운 자식 클래스로 대체하더라도 시스템이 문제없이 동작할 것이라는 것을 보장 

# 04 리스코프 치환 원칙

- 리스코프 치환 원칙을 한마디로 정리하면, 
    - 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.
    - 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.
- 샘플: 직사각형과 정사각형
    - 서로의 가정이 달라 리스코프 치환 원칙을 위배함
        - 직사각형의 가정: 너비와 높이가 다를 수 있다
        - 정사각형의 가정: 너비와 높이가 항상 동일하다.
    - 상속은 되었지만 위와 같이 리스코프 치환 원칙을 위배하면 서브타이핑이 아닌 서브클래싱

#### 클라이언트와 대체 가능성

- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다.
- 어떤 모델의 유효성은 클라이언트의 관점에서만 검증 가능하다.
- 대체 가능성을 결정하는 것은 클라이언트다.

#### is-a 관계 다시 살펴보기

- is-a는 클라이언트 관점에서 is-a일 때만 참이다.

#### 리스코프 치환 원칙은 유연한 설계의 기반이다.

- 클라이언트 입장에서 퍼블릭 인터페이스의 행동방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다는 것
- 리스코프 치환 원칙 위반은 잠재적인 개방-폐쇄 원칙 위반이다.

#### 타입 계층과 리스코프 치환 원칙

- 리스코프 치환 원칙을 준수해야만 서브 타이핑 관계가 된다.
- 구현 방법은 중요하지 않다.
- 슈퍼타입에 대해 기대하는 모든 것이 → 서브타입에게도 적용되어야 한다.

# 05 계약에 의한 설계와 서브타이핑

- 계약에 의한 설계
    - 사전조건: 메서드 호출 전 만족되어야 하는 조건. 클라이언트의 의무
    - 사후조건: 메서드 실행 후 클라이언트에게 보장해야 하는 조건. 서버의 의무
    - 클래스 불변식: 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야하는 것

#### 서브타입과 계약

- 사전조건
    - 서브타입에 더 강력한 사전조건을 정의할 수 없다.
    - 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
- 사후조건
    - 서브타입에 슈퍼타입과 같거나 더 강력한 사전조건을 정의할 수 있다.
    - 서브타입에 더 약한 사전조건을 정의할 수 없다.
