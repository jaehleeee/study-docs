# 12장 채팅 시스템 설계

## 1단계 요구사항
 * 응답지연 낮은 1:1 채닝
 * 최대 100명 참여가능한 그룹 채팅
 * 사용자 접속 상태 표시
 * 다양한 단말 지원 및 하나의 계정으로 여러 단말 동시 접속 지원
 * 푸시 알림

## 2단계 개략적 설계안 제시 및 동의 구하기
- 클라이언트들로부터 메시지 수신
- 메시지 수신자 결정 및 전달
- 수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관
- 어떤 통신 프로토콜을 사용할 것인가?
    - http: 검증되었고 쉽다. 그러나 메시지 수신이 까다롭다
    - 메시지 수신(서버에서 클라로)을 고려한 기법: 폴링, 롱 폴링, 웹 소켓

### 폴링

- 클라이언트가 주기적으로 서버에게 새 메시지 있는지 확인

### 롱폴링

- 새 메시지가 반환된거나 타임아웃 될 때까지 연결 유지
    - 같은 서버에 메시지가 오지 않을 가능성이 있기 때문에 애먼 서버에서 연결 유지하는 경우가 있을 수 있다.
    - 서버입장에서는 클라이언트가 연결을 유지하고 있는지 해제하고 있는지 확인이 쉽지 않음
    - 폴링보다는 덜하지만 여튼 주기적으로 확인이 필요

### 웹소켓

- 서버가 클리언트에게 비동기 메시지를 보낼 때 가장 널리 사용되는 기술
- 항구적, 양방향, 비동기적 메시지 전송 가능, 방화벽이 있는 곳에서도 잘 동작
- 대신 서버측에서 연결관리가 효율적으로 이루어져야함.

### 개략적 설계안

- 무상태 서비스
- 상태유지 서비스
- 제3자 서비스 연동: 푸시 알림

#### 무상태 서비스

- 전통적인 요청/응답, 보편적인 제공 기능들
    - ex) 로그인, 회원가입, 프로필 표시, **서비스탐색** 등

#### 상태 유지 서비스

- 유리하게 상태 유지가 필요한 서비스는 채팅 서비스
- 채팅 서버와 독립적인 네트워크 연결을 유지해야함. 보통 연결은 변경하지 않음.
- 서비스 탐색과 긴밀하게 협력하여 부하를 몰리지 않도록

### 제3자 서비스 연동

- 메시지 수신을 알려줄 목적

### 규모 확장성

- 동시 접속자가 1M이라고 가정하고 접속당 10K메모리가 필요하면 10GB 메모리라는 계산이 나옴
- 물론 서버한대는 규모의 확장성과 SPOF 관점에서 좋지 않지만 여기부터 출발해보자
- 메시지 중계 역할: 채팅 서버
- 접속 여부 관리 역할: 접속상태 서버
- 그 외 보편적인 상태 관리 역할: API 서버
- 푸시 역할: 알림 서버
- 채팅 이력 보관 역할: 키-값 저장소

### 저장소

- 데이터의 유형과 읽기/쓰기 연산의 패턴으로 저장소를 골라보자
    - 데이터 유형
        - 일반적인 데이터: 사용자 정보, 설정, 친구 목록
            - → 안정성이 좋은 관계형 데이터베이스, 다중화와 샤딩은 당연히 고려해야함.
        - 채팅 이력 = 메시지
            - 읽기/쓰기 연산의 패턴 파악 필요
                - 오래된 메시지 안보는 경향
                - 하지만 그래도 메시지를 조회하는 여러 기능들을 지원해야함
                    - 멘션만 보기, 점프..
                - 메시지는 매일 600억개를 처리한다고
                - 읽기/쓰기 비율
            - → 수평적 규모확장이 좋고 지연시간이 낮은  키-값 저장소 선택

### 데이터 모델

1:1 채팅을 위한 메시지 테이블

- message_id 키

그룹 채팅을 위한 메시지 테이블

- channel_id + message_id
    - channel_id 파티션 키로도 사용됨

메세지 ID

- 고유해야하고 정렬이 시간순으로 되야함
    - 1, rdbms의 auto increment
    - 2, snowflake의 아이디 생성기
    - 3, 지역적 순서 번호 생성기
        - 같은 그룹안에서만 순서 보장

## 3단계 상세 설계

### 서비스 탐색

- 클라이언트에게 가장 적합한 채팅 서버를 추천
    - 고려사항: 클라이언트의 위치, 서버의 용량
- 주키퍼를 사용해볼 수 있다. 주키퍼가 채팅서버를 관리하고 클라이언트에 따라 결정해준다.

### 메시지 흐름

1:1 채팅 메시지 처리 흐름

여러 단말 사이의 메시지 동기화

소규모 그룹 채팅에서의 메시지 흐름

- 사용자별로 큐를 할당하면 메시지 동기화 플로우가 간단해진다.

### 접속상태 표시

- 앞서 접송상태 서버(presense server)를 통해 관리
- 사용자의 상태 바뀌는 시나리오
    - 사용자 로그인
        - last_active_at 과 같은 타임스탬프로 보관
    - 로그아웃
    - 접속 장애(소위 인터넷 끊길떄)
        - 끊어졌다 안 끊어졌다 반복하면 깜빡일 수 있음 ㅋㅋ (새로운 의미일까..)
            - 박동(hearbeat)검사를 통해 문제 해결
                - 클라이언트가 주기적으로 박동 이벤트를 보내고 접속상태를 확인
    - 상태 정보의 전송(ex.프로필이 바뀌는것)
        - 발행-구독 모델을 사용해서 상태정보를 전달할 수 있으나 그룹 크기가 작을 때 효과적
        - 최신성은 떨어져도 특정 시점의 상태 정보로 확인되도록 함
        - 사용자가 원하면 갱신할 수 있는 인터페이스 제공

## 4단계 마무리

### 더 나아가 보기

- 사진이나 비디오 등 미디어를 지원하도록 하는 방법
- 종단간 암호화
- 클라이언트 캐시
- 로딩 속도 개선
- 오류 처리
