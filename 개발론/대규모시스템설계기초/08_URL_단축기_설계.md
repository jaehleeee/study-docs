# 8장 URL 단축기 설계

## 1단계 문제 이해 및 설계 범위 확정
 * 쓰기 연산 : 매일 1억개의 단축 url 생성
 * 초당 쓰기 연산 1억/24/3600 = 1160
 * 읽기 : 쓰기의 1/10으로 가정
 * 서비스를 10년간 운영한다고 가정하면 3650억개 레코드 보관해야 한다.
 * 축약전 URL 평균 길이 100 이라 가정하면
 * 3560억 * 100바이트 = 36.5TB

## 2단계 개략적 설계안

<img src="https://github.com/jaehleeee/study-docs/assets/48814463/664c7e7f-8ebb-4943-a6f9-44ebf1b614c0" width="500"/>

### API 엔드포인트
 * 단축 URL 생성 메서드 POST
 * URL 리디렉션용 엔드포인트 : 단축 url이 오면 원래 URL을 보내주기 위한 용도
### URL 리디렉션
 * URL을 받은 서버는 그 url을 원래 url로 바꿔서 301 응답에 Location 헤더에 넣어 반환한다.
 * 301과 302 차이
   * 301 Permanently Moved : 영구적으로 Location 헤더에 반환된 url로 이전되었다는 응답. 브라우저는 이 응답을 캐시한다.
   * 302 Found : 일시적으로 Location 헤더가 지정하는 Url에 의해 처리되어야 한다는 응답.
 * URL 리디렉션 구현하는 가장 직관적인 방법은 해시테이블을 사용하는 것.
   * 단축 URL 생성시 hashTable.put(단축url, 원래url)
   * 원래 URL = hashTable.get(단축url)
### URL 단축
 * 단축 url이 www.tinyurl.com/{hashValue} 형태라고 해보자.
 * f(긴URL) = 단축URL이 되는 f(x) 해시함수를 찾아야 한다.
 * 해시함수의 조건
   * 긴 url이 다르면 해시값도 달라야 한다.
   * 복원될 수 있어야 한다.
  
## 3단계 상세설계
### 데이터 모델
 * 개략적 설계에선 해시테이블에 저장한다고 했지만 초기 이후로는 메모리 용량 이슈로 이렇게 할 수 없다.
 * 더 나은 방법은 id, shortURL, longURL 을 관계형 DB에 저장하는 것이다.

### 해시함수
#### 해시값 길이
 * hashValue는 [0-9, a-z, A-Z] 문자로 구성되며 총 사용가능한 문자 개수는 10+26+26=62다.
 * 62^n >= 3650억인 n 최솟값을 찾아야 한다. -> n = 7일때 만족.
#### 해시 후 충돌 해소
 * 긴 url을 줄이려면 원래 url을 7글자로 줄여야 한다.
 * 손쉬운 방법은 이미 잘 알려진 해시 함수들(MD5, SHA-1)을 쓰는 것이다.
 * 그러나 이 해시함수들은 가장 짧아도 7글자를 넘는다.
 * 이 문제를 해결하기 위해서는 첫 7글자만 사용하되, 서로 충돌이 발생하면 충돌을 해소할때까지 사전에 정한 문자열을 해시값에 덧붙이는 것이다.
 * 이 방법의 단점은 1번 이상 데이터베이스를 조회하므로 오버헤드가 크다. 그래서 블룸필터를 사용하여 성능을 높일 수 있다.
#### base-62 변환
 * 진법 변환은 url 단축기에 자주 사용된다.
 * 62인 이유는 사용가능 문자 개수가 62개라서이다.

#### `해시 후 충돌 해소`와 `base-62` 비교

<img src="https://github.com/jaehleeee/study-docs/assets/48814463/17b36707-cbbe-409d-b691-02e306503a32" width="500"/>

### URL 단축기 상세 설계 (base-62 예시)
1. longURL 입력
2. DB에 이미 만든 단축 URL 응답 있는지 조회
3. (있으면) DB에 있는 단축 URL 응답
4. (없으면) 새로운 ID 생성 -> 단축 url 변환 -> DB 저장

### URL 리디렉션 상세 셜계
 * 쓰기보다 읽기를 더 자주하는 시스템이므로 캐시 활용

## 4단계 마무리 : 추가로 얘기해볼 주제
 * rate limiter
 * 웹 서버 규모 확장
 * 데이터베이스 규모 확장
 * 데이터 분석 솔루션
 * 가용성, 데이터 일관성, 안정성


