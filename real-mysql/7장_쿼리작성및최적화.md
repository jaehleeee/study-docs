# 7장 쿼리 작성 및 최적화
 * SQL이란? DDL과 dML로 구성.
    * DDL : 데이터베이스나 테이블의 구조를 변경
    * DML : 테이블의 데이터를 조작.
       * SELECT 를 쿼리, INSERT/UPDATE/DELETE를 statement라고 구분하기도 한다.

## 7.1 쿼리와 연관된 시스템 설정
### 7.1.1 SQL 모드
 * 시스템 설정을 통해서 얼마나 유연하게 쿼리를 적용할지 결정
    * 컬럼 길이가 정해진 것보다 길때 에러를 발생시킬지 여부, 데이터 타입이 다른 값일때 바꿔서 저장할지 에러를 발생시킬지.. 등등
### 7.1.2 영문 대소문자 구분
 * 윈도우 계열에서는 구분하지 않지만, 유닉스 계열에서는 구분한다.
 * MYSQL 서버가 대소문자를 구분하지 않고 사용하려면 서버 설정 파일에서 `loser_case_table_names` 를 설정하면 된다. 0으로 설정하면 대소문자를 구분한다. 1로 설정하면 모두 소문자로만 저장된다. 2로 설정하면 대소문자 구분해서 저장하지만 쿼리에서는 구분하지 않는다.
### 7.1.3 MYSQL 예약어
 * 데이터베이스나 테이블, 그리고 컬럼 이름을 예약어와 같은 키워드로 생성해서 사용하려면 역따옴표나 쌍따옴표로 감싸줘야한다.

## 7.2 매뉴얼의 SQL 문법 표기를 읽는 방법
 * 책을 한번 읽어보자.

## 7.3 MYSQL 연산자와 내장 함수
### 7.3.1 리터럴 표기법
 * 문자열 : 표준은 홀따옴표지만, mysql 에서는 쌍따옴표도 가능.
 * 숫자 : 따옴표 없이 입력하면 됨. 문자열과 숫자 타입 비교시 숫자 타입이 우선시 되므로 문자타입을 숫자 타입으로 변환하게 됨. 이때 인덱스 적용이 안될 수 있기 때문에 주의.
 * 날짜 : 다른 DBMS는 날짜 타입 비교하거나 INSERT 할때 `DATE` 타입 변환이 필요하지만, mysql 에서는 날짜 포맷으로 입력하면 자동으로 `DATE`, `DATETIME` 값으로 변환한다. (물론 변환 함수도 있다. `STR_TO_DATE()`)
    * 문자열과 날짜 비교시, 문자열을 날짜 타입으로 자동 변환하여 비교한다.
 * 불리언 : `BOOL`, `BOOLEAN` 타입이 있지만 실제로 저장은 `TINYINT` (0 또는 1) 타입으로 저장.

### 7.3.2 연산자
 * `<=>` 연산자는 `=` 와 같으며, 부가적으로 NULL 값에 대한 비교까지 수행 가능.
 * `LIKE`에서 사용할 수 있는 와일드카드는 `%`(0 또는 1개 이상의 모든 문자) , `_`(딱 1개에 대해 모든 문자) 2가지.
 * `IN` 연산자 입력에 상수 말고 서브 쿼리이면 상당히 느릴 수 있음. NULL 검색할 수 없음. `NOT IN` 은 인덱스 풀 스캔

### 7.3.3 내장 함수
 * 현재시각 조회
    * `NOW()`, `SYSDATE()` 차이점 : `NOW()` 는 하나의 쿼리에서 여러 `NOW()`가 실행되어도 모두 같은 값. `SYSDATE()`는 하나의 쿼리 안에서도 여러 `SYSDATE()`가 호출 시점마다 값이 다름.
 * 날짜 시간 포맷
    * 날짜타입 -> 문자열 `DATE_FORMAT(날짜 함수, 포맷)` : DATETIME 타입의 컬럼이나 값을 원하는 형태의 문자열로 변환. `DATE_FORMAT(NOW(), '%Y-%m-%d')` : 2021-04-18
    * 문자열 -> 날짜타입 `STR_TO_DATE(문자열, 포맷)` : 표준 형식이면 자동으로 문자열을 날짜타입으로 변환하지만, 그렇지 않은 경우 해당 함수를 이용해 변환해주어야 한다.
 * 날짜 연산 (`DATE_ADD(날짜, INTERVAL n [YEAR, MONTH, DAY..])`, `DATE_SUB(..)`)
 * `UNIX_TIMESTAMP()` : 날짜를 타임스탬프 값으로 변환.
 * `FROM_UNIXTIME()` : 타임스탬프를 날짜로 변환.
 * `GROUP_CONCAT(컬럼 SEPERATOR '/')` : 그룹함수 중 하나로, 여러 값들을 한줄로 만들고 구분자 설정할 수 있는 값.
 * `COUNT(*)`에서 *의 의미는 모든 컬럼을 가져오는 것이 아니라 레코드 자체를 의미한다. 따라서 `COUNT(*)` 이나 `COUNT(1`)` 이나 같은 속도로 처리된다.
    * 단, 조건절이 있을 때의 `COUNT(*)` 는 실제 쿼리를 실행해야 하므로 주의.
    * 단, `COUNT()` 의 인자로 컬럼명이나 표현식이 들어가면 NULL 이 아닌 레코드 건수만 계산하므로 주의해야 한다.

## 7.4 SELECT
### 7.4.1 각 절의 처리 순서
 1. 드라이빙 테이블 읽기
 2. 드리븐 테이블 읽기 - 드라이빙 테이블과 함께 where 조건 및 조인 실행
 3. GROUP BY 적용
 4. DISTINCT 적용
 5. HAVING 조건 필터링
 6. ORDER BY 정렬
 7. LIMIT 적용
### 7.4.2 WHERE 절과 GROUP BY 절, 그리고 ORDER BY 절의 인덱스 사용
#### 인덱스 사용을 위한 규칙
 * 가장 기본적인 규칙은 인덱스된 칼럼의 값 자체를 변환하지 않고 그대로 사용해야 한다.
    * `WHERE salary*10 > 15000` 이렇게 하면 인덱스 사용 못함.
    * 컬럼에 복잡한 계산이 필요하다면? 미리 계산된 값을 별도의 컬럼으로 만들어서 인덱스 생성하는 것이 유일한 해결책.
    * 데이터 타입이 다르면 일치시켜서 비교를 하게 되는데, 이때 인덱스 컬럼이 변환되지 않도록 미리 타입을 일치시켜놓아야 한다.
       * `WHERE AGE = 2` AGE 컬럼이 varchar 라면 숫자 우선순위가 높기 때문에 varchar를 숫자로 변환하게 되어 인덱스 사용하지 못함.
#### WHERE 절 인덱스 사용
 * 범위 제한 조건과 체크 조건 2가지 방식으로 구분.
    * 범위 제한 조건 : 동등 비교 조건이나 IN 으로 구성된 조건이 인덱스를 구성하는 컬럼과 얼마나 좌측부터 일치하는가
 * WHERE 절에서의 각 조건이 명시된 순서는 중요치 않고, 그 컬럼에 대한 조건이 있는지 없는지가 중요.
#### GROUP BY 절 인덱스 사용
 * GROUP BY 절에 명시된 컬럼의 순서가 인덱스를 구성하는 컬럼의 순서와 같으면 GROUP BY절은 일단 인덱스를 사용할 수 있다.
    * GROUP BY 절에 명시된 컬럼이 하나라도 인덱스에 없으면 GROUP BY 절은 인덱스를 이용하지 못한다.
 * 인덱스를 구성하는 컬럼들 중 앞쪽 컬럼이 WHERE에서 상수와 동등 비교 조건절로 있다면 나머지 컬럼만 GROUP BY 절에 사용되어도 인덱스를 사용할 수 있다.
#### ORDER BY 절 인덱스 사용
 * GROUP BY 인덱스 사용 조건과 매우 흡사.
 * 다만, ORDER BY 에 있는 컬럼들의 정렬 방향 옵션이 모두 한쪽으로 같아야 한다.
#### WHERE 절과 ORDER(또는 GROUP) BY 절의 인덱스 사용 케이스
 * 인덱스를 사용하려면 아래 3가지 케이스여야 한다.
 1. WHERE 절과 ORDER(또는 GROUP) BY 절이 동시에 같은 인덱스 사용
     * WHERE 절에 사용된 컬럼과 ORDER BY 절의 정렬 대상 컬럼이 모두 하나의 인덱스에 연속해서 포함되어 있을 때 가능.
 2. WHERE 절만 인덱스 사용
     * WHERE 절로 인덱스가 사용되어 레코드가 조회되면 Filesort 를 통해 정렬이 수행됨.
 3. ORDER BY 절만 인덱스 사용
     * ORDER BY 절의 순서대로 인덱스를 읽으면서 레코드 한 건씩을 WHERE 절의 조건에 일치하는지 비교해 일치하지 않을 때는 버리는 형태로 처리.
#### WHERE 조건절에서 범위 조건인 경우
 * 인덱스 사용 가능 : `... WHERE COL1 > 10 ORDER BY COL1, COL2, COL3`
 * 인덱스 사용 불가능 : `... WHERE COL1 > 10 ORDER BY COL2, COL3`
#### GROUP BY 절과 ORDER BY 절 인덱스 사용
 * 각 절에 명시된 칼럼이 순서와 내용이 모두 같아야 한다. 둘 중 하나만 인덱스를 이용하는 케이스는 없다.
 * mysql의 GROUP BY는 컬럼에 대한 정렬까지 함께 수행하는 것이 기본 작동 방식이므로 ORDER BY는 생략해도 동일하게 동작한다.
### 7.4.3 WHERE 절의 비교 조건 사용시 주의사항
 * mysql에서는 NULL 도 인덱스로 관리된다. -> NULL을 하나의 값으로 인정한다는 의미.
 * DATE, DATETIME 타입은 문자열과 비교시 문자열로 자동 변환. -> 인덱스 컬럼이 변환되지 않도록 비교 상수 값을 해당 타입으로 변환하는 것이 좋다.
 * DATE 타입끼리 변환
    * `DATE()` : DATETIME 타입으로 DATE 타입으로
    * `FROM_UNIXTIME()` : TIMESTAMP 타입을 DATETIME 타입으로
    * `UNIX_TIMESTAMP()` : DATETIME 타입을 TIMESTAMP 타입으로
### 7.4.4 DISTINCT
 * 

## 7.5 ㅇ
### 7.5.1 ㅇ
 * 
### 7.5.2 ㅇ
 * 
### 7.5.3 ㅇ
 * 
### 7.5.4 ㅇ
 * 