# 6장 실행 계획
 * DBMS에서도 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터 분포를 참조하여 최적의 실행 계획을 수립하는 것이 필요하다. 이러한 작업을 **옵티마이저**가 담당한다.
  * `EXPLAIN` 이라는 명령어를 통해 쿼리의 실행 계획을 확인할 수 있다.

## 6.1 개요
### 6.1.1 쿼리 실행 절차
 1. SQL 파싱 : 사용자로부터 요청된 쿼리를 MYSQL 서버가 이해할 수 있는 수준으로 분리한다. 
    *  SQL 파서 모듈이 처리힌다. 파스 트리를 만든다.
 2. 실행 계획 : 파스 트리를 확인하면서 어떤 테이블, 어떤 인덱스를 사용할지 등을 정한다.
    * 옵티마이저에서 처리
 3. 실행 계획을 바탕으로 스토리지 엔진으로부터 데이터를 불러온다.

### 6.1.2 옵티마이저의 종류
 * 비용 기반 옵티마이저와 규칙 기반 옵티마이저가 있다.
 * 대부분 DBMS는 비용 기반 옵티마이저를 선택
 * 규칙 기반 옵티마이저는 기본적으로 대상 테이블 정보를 고려하지 않고 미리 정해놓은 우선순위 규칙에 따라 실행 계획을 수립하는 방식. 현재는 대부분 사용되지 않고 있다.


## 6.2 실행 계획 분석
 * 실행 계획의 위쪽에 출력된 결과일수록(id 컬럼 값이 작을수록) 먼저 접근하는 테이블이다.
### 6.2.1 id 칼럼
 * 단위 SELECT별로 구분되는 식별자 값.
 * 단위 SELECT를 의미한다.
 * 하나의 SELECT 문장 안에서 여러개의 테이블을 조인하면 조인되는 테이블 개수만큼 실행계획 레코드가 출력되지만, id는 모두 같다.
### 6.2.2 select_type 컬럼
 * 각 단위 SELECT 가 어떤 타입인지 표시하는 컬럼.
 * DEPENDENT 키워드가 붙은 쿼리는 외부에 의존적이므로 외부보다 먼저 실행될 수 없으므로 비효율적인 경우가 많다.

|종류|의미|
|---|---|
|SIMPLE|유니온이나 서브쿼리가 없는 단순 단위 쿼리|
|PRIMARY|유니온이나 서브쿼리가 있는 SELECT 중 가장 바깥쪽에 있는 단위 쿼리|
|UNION|유니온 쿼리 중 두번째 이후 단위 쿼리|
|DEPENDENT UNION|유니온 이나 유니온올로 결합된 쿼리가 외부의 영향을 받는 경우|
|UNION RESULT|유니온 이나 유니온올 결과를 담아두는 임시 테이블|
|SUBQUERY|FROM 절 이외에서 사용되는 서브쿼리|
|DEPENDENT SUBQUERY|외부 영향을 받는 서브 쿼리|
|DERIVED|FROM 절에 서브쿼리가 사용된 경우 단위 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블로 저장하는데 이 임시 테이블을 파생 테이블이라 부름.|
|UNCACHEABLE SUBQUERY|서브쿼리가 하나만 있더라도 한번만 실행되는 것은 아님. 이때를 위해 DB 서버는 쿼리 결과를 캐쉬해두는데 캐쉬가 불가능한 경우를 의미.|
|UNCACHEABLE UNION|유니온과 UNCACHEABLE 개념을 혼합하여 의미 파악 가능.|

### 6.2.3 table 컬럼
 * 사용된 테이블.
 * 별도의 테이블을 사용하지 않으면 NULL이 표시됨.
 * <>로 둘러쌓여 있다면 임시 테이블 의미, 숫자는 id 컬럼 의미.
### 6.2.4 type 컬럼
 * MYSQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었느냐를 의미힌다. (인덱스 사용여부 등)
 * 아래 정리된 테이블 아래로 내려갈수록 성능이 안 좋아진다고 보면 된다.
 * 인덱스 풀 스캔이나 풀 테이블 스캔 처럼 디스크 I/O를 많이 유발하는 작업을 위해 DB서버들은 한꺼번에 많은 페이지를 읽어들이는 `Read Ahead` 기능을 제공한다.

|종류|의미|
|---|---|
|system|레코드가 1건만 혹은 한 건도 없는 테이블을 참조하는 경우|
|const|쿼리가 프라이머리 키나 유니크 키 칼럼을 조건절에 사용하여 딱 1건의 결과를 반환하는 경우, UNIQUE INDEX SCAN 이라고도 부름.|
|eq_ref|여러 테이블 join 쿼리에서만 표시됨. 처음 읽는 테이블 컬럼 값을, 그 다음 읽을 테이블의 프라이머리 키나 유니크 키 컬럼 검색 조건에 사용될때 eq_ref 라고 한다. 인덱스가 다중 컬럼이라면 인덱스에 사용된 컬럼 전부 사용되어야 한다. 또한 두번째 이후 읽는 테이블 결과가 반드시 1건만 존재해야 한다.|
|ref|eq_ref 처럼 join 이나 키, 반드시 1건 보장 등의 제약이 없다. 인데스의 종류와 관계없이 동등(Equal) 조건으로 검색할때 사용된다.|
|fulltext|전문 검색(full text) 인덱스를 사용해 레코드를 읽는 접근 방법. 전문 검색은 MATCH...AGAINST.. 구문을 사용해야 하며 전문 검색용 인덱스가 준비돼 있어야 한다.|
|ref_or_null|ref 접근 방식 중 null 비교가 추가된 형태. 실제 업무상에선 거의 보이지 않음.|
|unique_subquery|`IN (서브쿼리)` 형태의 쿼리 중 서브 쿼리 결과가 유니크한 결과만 반환하는 경우.|
|index_subquery|`IN (서브쿼리)` 형태의 쿼리 중 서브 쿼리 결과가 중복된 결과일수도 있지만 인덱스를 이용하여 중복을 제거할 수 있는 경우 사용되는 방식.|
|range|흔히 아는 인덱스 레인지 스캔 방식. 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미.|
|index_merge|2개 이상의 인덱스를 이용해 각 결과를 만들어 결과를 병합하는 방식.|
|index|인덱스 풀 스캔. 인덱스를 사용하니까 효율적이겠구나~ 라며 착각할 수 있으나 효율적이진 않음.|
|ALL|풀 테이블 스캔.|

### 6.2.5 possible_keys 컬럼
 * 무시해도 됨.
### 6.2.6 key 컬럼
 * 실행계획에 사용된 인덱스
### 6.2.7 key_len 컬럼
 * 쿼리를 처리하기 위해 다중 컬럼으로 구성된 인덱스에서 몇개의 컬럼을 사용했는지 알려줌.
 * 몇 바이트를 사용했는지 알려준다.
### 6.2.8 ref 컬럼
 * 접근 방식이 ref 일때, 참조 조건(Equal 비교조건)으로 어떤 값이 제공됐는지 보여준다.
### 6.2.9 rows 컬럼
 * 각 처리 방식이 얼마나 많은 레코드를 일고 비교해야하는지 예측해본 값. (예측 값이라서 정확하진 않음.)
 * 반환하는 레코드의 결과 예측치가 아니라 쿼리 처리를 위해 얼마나 레코드를 사용하는지를 의미하는 것이니 헤깔리지 말 것.
### 6.2.10 Extra 컬럼
 * 실행계획 중 쿼리 성능에 관련된 중요한 내용이 Extra 컬럼에 표시된다.
 * 정리하기엔 항목이 많으니 책을 참고하자.


## 6.3 MySQL 주요 처리 방식
 * 풀 테이블 스캔을 제외한 나머지는 모두 스토리지 엔진이 아니라 MySQL 엔진에서 처리된다.
### 6.3.1 풀 테이블 스캔
 * 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 대부분의 DBMS는 풀 테이블 스캔을 실행할 때 여러개의 블록이나 페이지를 한꺼번에 여러개 읽어오는 기능이 있다. MySQL은 이 기능이 있지만 몇개씩 불러올지 설정하는 변수는 없다.(근데 또 InnoDB에는 있다.)
### 6.3.2 ORDER BY (Using filesort)
 * 인데스를 사용해 정렬하는 방법과 Filesort 라는 별도의 처리를 이용하는 방법으로 나뉜다.
 * 인덱스를 사용하면 더 빠르지만, 인덱스 때문에 디스크 공간을 더 많이 필요로 한다.
 * Filesort는 인덱스가 없으니 디스크 공간 차지하진 않겠지만 레코드 많아질수록 느리다. Extra 컬럼에 `Using filesort` 표시된다.
#### Sort buffer
 * MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다.
 * 정렬해야할 레코드 건수가 소트 버퍼로 할당된 공간보다 크다면 정렬해야할 레코드를 여러 조각으로 나눠 처리하는데 이때 임시 저장을 위해 디스크를 사용한다. 이때 레코드 건수가 많을수록 디스크 쓰기/읽기가 더 많이 반복된다.
 * 테스트 결과 소트 버퍼 크기는 56KB ~ 1MB가 적절
#### 정렬 알고리즘
 * 레코드 전체를 소트 버퍼에 담을지, 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 알고리즘을 나뉜다.
 1. 싱글 패스 알고리즘
    * 정렬 기준 컬럼을 포함해 SELECT 되는 컬럼 전부를 담아서 정렬을 수행하는 방법.
 2. 투 패스 알고리즘
    * 정렬 대상 컬럼과 프라이머리 키만 소트 버퍼에 담아서 정렬하고, 이후 정렬된 것을 기준으로 필요한 셀렉트 필드들을 가져온다
#### 정렬의 처리 방식 (아래일수록 성능 떨어짐)
 * 인덱스 사용한 정렬
 * 드라이빙 테이블만 정렬한 다음 조인
 * 조인 수행 결과를 임시 테이블에 저장 후 임시 테이블에서 정렬
### 6.3.3 GROUP BY 처리
 * 인덱스를 사용하는 경우(차례대로 인덱스를 읽는 인덱스 스캔, 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔)와 사용하지 못하는 겨우로 나뉨.
### 6.3.4 DISTINCT 처리
 * 집합함수와 함께 사용되는 경우와 집합함수가 없는 경우로 나뉜다. (Distinct 영향 범위가 달라지기 때문)
 * 집합함수와 함께 사용될 때 인덱스를 사용하지 못하면 항상 임시 테이블이 필요하다. 그러나 Extra 컬럼에 Using Temporary가 출력되지 않는다.
 * `DISTINCT first_name, last_name FROM name_table` 예시에서 first_name만 중복없이 가져오는 것이 아니라 first_name와 last_name 가 함께 중복없는 케이스를 가져오는 것이니 주의해야함.
### 6.3.5 임시 테이블
 * mysql 엔진이 사용하는 임시 테이블은 처음 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다.
 * 보통 생성할 테이블이 아주 클 경우, 디스크에 생성된다. (이 경우 성능에 이슈가 될 수 있다.)
### 6.3.6 테이블 조인
 * 조인 처리에선 어느 테이블을 먼저 읽을지가 중요.
 * 아우터 테이블은 이너 테이블보다 먼저 읽어야 하며, 조인에서 주도적인 역할을 한다고 해서 드라이빙 테이블이라고 한다.
 * 조인의 결과는 드라이빙 테이블 읽은 순서대로 정렬되어 반환된다.
#### 조인 버퍼를 이용한 조인
 * 드리븐 테이블에서 인덱스를 사용할 수 없다면 일치하는 레코드 수 만큼 풀 테이블 스캔이 진행되어 쿼리가 매우 느려질 수 있다. 따라서 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 사용할 수 있는 방향으로 실행 계획을 수립힌다.
 * 어떤 방식으로도 풀 스캔을 피할 수 없다면, 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시 후 드리븐 테이블과 메모리 캐시를 조인하는 형태로 처리한다. 이때 메모리 캐시를 조인 버퍼라고 한다.