# 6장 실행 계획
 * DBMS에서도 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터 분포를 참조하여 최적의 실행 계획을 수립하는 것이 필요하다. 이러한 작업을 **옵티마이저**가 담당한다.
  * `EXPLAIN` 이라는 명령어를 통해 쿼리의 실행 계획을 확인할 수 있다.

## 6.1 개요
### 6.1.1 쿼리 실행 절차
 1. SQL 파싱 : 사용자로부터 요청된 쿼리를 MYSQL 서버가 이해할 수 있는 수준으로 분리한다. 
    *  SQL 파서 모듈이 처리힌다. 파스 트리를 만든다.
 2. 실행 계획 : 파스 트리를 확인하면서 어떤 테이블, 어떤 인덱스를 사용할지 등을 정한다.
    * 옵티마이저에서 처리
 3. 실행 계획을 바탕으로 스토리지 엔진으로부터 데이터를 불러온다.

### 6.1.2 옵티마이저의 종류
 * 비용 기반 옵티마이저와 규칙 기반 옵티마이저가 있다.
 * 대부분 DBMS는 비용 기반 옵티마이저를 선택
 * 규칙 기반 옵티마이저는 기본적으로 대상 테이블 정보를 고려하지 않고 미리 정해놓은 우선순위 규칙에 따라 실행 계획을 수립하는 방식. 현재는 대부분 사용되지 않고 있다.


## 6.2 실행 계획 분석
 * 실행 계획의 위쪽에 출력된 결과일수록(id 컬럼 값이 작을수록) 먼저 접근하는 테이블이다.
### 6.2.1 id 칼럼
 * 단위 SELECT별로 구분되는 식별자 값.
 * 단위 SELECT를 의미한다.
 * 하나의 SELECT 문장 안에서 여러개의 테이블을 조인하면 조인되는 테이블 개수만큼 실행계획 레코드가 출력되지만, id는 모두 같다.
### 6.2.2 select_type 컬럼
 * 각 단위 SELECT 가 어떤 타입인지 표시하는 컬럼.
 * DEPENDENT 키워드가 붙은 쿼리는 외부에 의존적이므로 외부보다 먼저 실행될 수 없으므로 비효율적인 경우가 많다.

|종류|의미|
|---|---|
|SIMPLE|유니온이나 서브쿼리가 없는 단순 단위 쿼리|
|PRIMARY|유니온이나 서브쿼리가 있는 SELECT 중 가장 바깥쪽에 있는 단위 쿼리|
|UNION|유니온 쿼리 중 두번째 이후 단위 쿼리|
|DEPENDENT UNION|유니온 이나 유니온올로 결합된 쿼리가 외부의 영향을 받는 경우|
|UNION RESULT|유니온 이나 유니온올 결과를 담아두는 임시 테이블|
|SUBQUERY|FROM 절 이외에서 사용되는 서브쿼리|
|DEPENDENT SUBQUERY|외부 영향을 받는 서브 쿼리|
|DERIVED|FROM 절에 서브쿼리가 사용된 경우 단위 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블로 저장하는데 이 임시 테이블을 파생 테이블이라 부름.|
|UNCACHEABLE SUBQUERY|서브쿼리가 하나만 있더라도 한번만 실행되는 것은 아님. 이때를 위해 DB 서버는 쿼리 결과를 캐쉬해두는데 캐쉬가 불가능한 경우를 의미.|
|UNCACHEABLE UNION|유니온과 UNCACHEABLE 개념을 혼합하여 의미 파악 가능.|

### 6.2.3 table 컬럼
 * 사용된 테이블.
 * 별도의 테이블을 사용하지 않으면 NULL이 표시됨.
 * <>로 둘러쌓여 있다면 임시 테이블 의미, 숫자는 id 컬럼 의미.
### 6.2.4 type 컬럼
 * MYSQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었느냐를 의미힌다. (인덱스 사용여부 등)
 * 아래 정리된 테이블 아래로 내려갈수록 성능이 안 좋아진다고 보면 된다.
 * 인덱스 풀 스캔이나 풀 테이블 스캔 처럼 디스크 I/O를 많이 유발하는 작업을 위해 DB서버들은 한꺼번에 많은 페이지를 읽어들이는 `Read Ahead` 기능을 제공한다.

|종류|의미|
|---|---|
|system|레코드가 1건만 혹은 한 건도 없는 테이블을 참조하는 경우|
|const|쿼리가 프라이머리 키나 유니크 키 칼럼을 조건절에 사용하여 딱 1건의 결과를 반환하는 경우, UNIQUE INDEX SCAN 이라고도 부름.|
|eq_ref|여러 테이블 join 쿼리에서만 표시됨. 처음 읽는 테이블 컬럼 값을, 그 다음 읽을 테이블의 프라이머리 키나 유니크 키 컬럼 검색 조건에 사용될때 eq_ref 라고 한다. 인덱스가 다중 컬럼이라면 인덱스에 사용된 컬럼 전부 사용되어야 한다. 또한 두번째 이후 읽는 테이블 결과가 반드시 1건만 존재해야 한다.|
|ref|eq_ref 처럼 join 이나 키, 반드시 1건 보장 등의 제약이 없다. 인데스의 종류와 관계없이 동등(Equal) 조건으로 검색할때 사용된다.|
|fulltext|전문 검색(full text) 인덱스를 사용해 레코드를 읽는 접근 방법. 전문 검색은 MATCH...AGAINST.. 구문을 사용해야 하며 전문 검색용 인덱스가 준비돼 있어야 한다.|
|ref_or_null|ref 접근 방식 중 null 비교가 추가된 형태. 실제 업무상에선 거의 보이지 않음.|
|unique_subquery|`IN (서브쿼리)` 형태의 쿼리 중 서브 쿼리 결과가 유니크한 결과만 반환하는 경우.|
|index_subquery|`IN (서브쿼리)` 형태의 쿼리 중 서브 쿼리 결과가 중복된 결과일수도 있지만 인덱스를 이용하여 중복을 제거할 수 있는 경우 사용되는 방식.|
|range|흔히 아는 인덱스 레인지 스캔 방식. 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미.|
|index_merge|2개 이상의 인덱스를 이용해 각 결과를 만들어 결과를 병합하는 방식.|
|index|인덱스 풀 스캔. 인덱스를 사용하니까 효율적이겠구나~ 라며 착각할 수 있으나 효율적이진 않음.|
|ALL|풀 테이블 스캔.|

### 6.2.5 possible_keys 컬럼
 * 무시해도 됨.
### 6.2.6 key 컬럼
 * 실행계획에 사용된 인덱스
### 6.2.7 key_len 컬럼
 * 쿼리를 처리하기 위해 다중 컬럼으로 구성된 인덱스에서 몇개의 컬럼을 사용했는지 알려줌.
 * 몇 바이트를 사용했는지 알려준다.
### 6.2.8 ref 컬럼
 * 접근 방식이 ref 일때, 참조 조건(Equal 비교조건)으로 어떤 값이 제공됐는지 보여준다.
### 6.2.9 rows 컬럼
 * 각 처리 방식이 얼마나 많은 레코드를 일고 비교해야하는지 예측해본 값. (예측 값이라서 정확하진 않음.)
 * 반환하는 레코드의 결과 예측치가 아니라 쿼리 처리를 위해 얼마나 레코드를 사용하는지를 의미하는 것이니 헤깔리지 말 것.
### 6.2.10 Extra 컬럼
 * 실행계획 중 쿼리 성능에 관련된 중요한 내용이 Extra 컬럼에 표시된다.
 * 정리하기엔 항목이 많으니 책을 참고하자.