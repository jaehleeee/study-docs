# Consumer 내부 구조
 * 카프카 클러스터 중 리더 파티션이 있는 브로커에서 데이터를 컨슈머로 전송하면 Consumer의 Fetcher가 데이터를 받는다.
 * fetcher에서 데이터를 모은 뒤 completedFetches로 만들어진다. completedFetches가 되어야 poll() 메서드로 전송이 가능하다.
 * poll() 메서드를 통해 ConsumerRecords 라는 객체로 브로커 -> 컨슈머 그룹으로 보내진다.
 * ConsumerRecords 는 record 들이 복수개 들어가 있고, 각 record에 오프셋이 포함되어 있다.
 * 오프셋을 가진 record 처리가 완료되면 커밋을 보내 어떤 오프셋까지 처리가 된 것인지 알린다.

![image](https://github.com/jaehleeee/study-docs/assets/48814463/ab0d82ef-0ca4-45d2-ac8e-49a6e8fe13ff)


# Consumer group
 * 컨슈머 그룹으로 묶인 컨슈머들은 토픽의 1개 이상 파티션들에 할당되어 데이터를 가져갈 수 있다.
 * 1개의 파티션에는 최대 1개의 컨슈머 할당이 가능하다.
 * 반대로 1개의 컨슈머에는 여러개의 파티션 할당이 가능하다.
 * 결국, `컨슈머 그룹의 컨슈머 개수 <= 파티션 개수` 이어야 한다.


## 리밸런싱
 * 컨슈머 그룹 중 일부 컨슈머가 장애가 발생하면 장애가 발생한 컨슈머에 할당된 파티션은 장애가 발생하지 않은 컨슈머에 소유권이 넘어간다.
 * 이렇게 파티션과 컨슈머 할당이 변경되는 것을 리밸런싱이라고 한다.
 * 리밸런싱 발생은 크게 2가지 케이스다.
    * 컨슈머 그룹에 컨슈머 신규 추가되는 상황
    * 컨슈머 그룹에 컨슈머 제외되는 상황
 * 리밸런싱 동작을 커스텀하게 구현할 수도 있는데, `RebalanceListener` 를 이용하면 된다.
 * 파티션 개수가 많을수록 리밸런싱 시간이 길어진다. (장애로 이어질 수 있다)


## 커밋
 * 컨슈머가 카프카 브로커로부터 데이터를 어디까지 가져갔는지 기록하는 것을 커밋이라고 한다.
 * 토픽별로 파티션을 어떤 컨슈머 그룹이 몇번째 가져갔는지를 카프카 브로커 내부 토픽인 `__consumer_offsets`에 기록된다.


## Assignor
 * 컨슈머와 파티션의 할당 정책
 * 카프카에서는 3가지 assigner를 제공
    * RangeAssignor : 각 토픽에서 파티션을 숫자로 정렬, 컨슈머를 사전 순서로 정렬하여 할당 (카프카 2.5.0에서 디폴트 assigner)
    * RoundRobinAssignor : 모든 파티션을 컨슈머에서 번갈아가면서 할당
    * StickyAssignor : 최대한 파티션을 균등하게 배분하면서 할당
