# 토픽과 파티션
 * 토픽은 1개 이상의 파티션으로 구성되어 있다.
 * 파티션의 큐처럼 선입선출 구조다.
 * 파티션에는 프로듀서가 보낸 레코드(데이터)가 저장된다.
 * 파티션 레코드들은 컨슈머가 가져가더라도 삭제되지 않는다. (별개로 관리된다)

## 토픽 생성시 파티션이 배치되는 방법
 * 브로커가 3개, 파티션이 5개인 토픽을 생성되게 되면
 * 0번 브로커부터 Round-Robin 방식으로 리더 파티션들이 생성된다.
 * 카프카 클라이언트는 리더 파티션과 통신하게 되므로 여러 브로커에 골고루 통신이 분산된다.

<img width="650" alt="image" src="https://github.com/jaehleeee/study-docs/assets/48814463/01ef8cda-f083-4412-9efa-02dcd9bd9835">

## 특정 브로커에 리더 파티션이 쏠리는 현상이 생기면?
 * 카프카에서 제공되는 kafka-reassign-partitions.sh 명령 스크립트로 파티션을 재분배할 수 있다.

## 파티션 개수와 컨슈머 개수의 처리량
 * 파티션은 카프카 병렬 처리의 핵심이다.
 * 컨슈머 개수 <= 파티션 개수
    * 컨슈머가 더 많아도 처리할 파티션이 없다.
 * 컨슈머 개수를 스케일아웃하면서 파티션 개수도 같이 늘려야 한다.

## 파티션 개수를 줄이는 것은 불가능하다.
 * 파티션을 늘릴때는 신중해야한다.
 * 토픽을 삭제하고 재생성하는 방법외에는 없다.


## 카프카 브로커의 파티션 분배는 프로듀서의 `파티셔너`가 한다
 * 레코드에 포함된 메시지 키 또는 값에 따라서 파티션의 위치가 결정된다.
 * 파티셔너를 따로 설정하지 않으면 디폴트로 `UniformStickyPartitioner` 로 설정된다.
   * `UniformStickyPartitioner` 는 메시지 키가 있을때와 없을때 동작이 다르다.
     * 메시지 키가 있다면, hash(메시지 키) -> 파티션 번호가 결정
       * 이 경우 메시지 키가 동일한 메시지들에 대해서는 순서를 지키면서 메시지를 전송할 수 있다.
       * 그 이유는 파티션 내부에서는 선입선출 구조이기 때문
     * 메시지 키가 없다면, 라운드 로빈으로 파티션에 들어간다.
       * 단, 배치 단위로 데이터를 보낸다.
 * 파티셔너 인터페이스를 활용해서 파티셔너를 만들면 커스텀하게 파티셔너를 만들수도 있다

![image](https://github.com/jaehleeee/study-docs/assets/48814463/37113701-6f7e-4385-a618-ba46f4d81d90)
