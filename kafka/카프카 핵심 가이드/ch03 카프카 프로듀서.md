# 3장 카프카 프로듀서

## 3.1 프로듀서 개요
 * 카프카에 메시지를 쓰는 작업은 ProducerRecord 객체를 생성함으로써 시작된다.
 * 여기서 토픽과 밸류 지정은 필수사항이지만, 키와 파티션 지정은 선택사항이다.
 * ProducerRecord 를 전송하는 API를 호출했을 때 프로듀서가 가장 먼저 하는 일은 키와 값 객체가 네트워크 상에서 전송될 수 있도록 직렬화해서 바이트 배열로 변환하는 과정이다.
 * 그다음은 파티션 지정을 위해 파티셔너에게 보낸다. 파티셔너 결정은 ProducerRecord 객체의 키 값.
 * 파티션이 결정되면, 이 레코드를 같은 토픽 파티션으로 전송될 레코드들을 모은 레코드 배치 (reocrd batch)에 추가한다.
 * 그러면 별도의 스레드가 이 레코드 배치를 적절한 카프카 브로커에게 전송한다.
 * 브로커가 메시지를 받으면 응답을 주는데, 레코드 오프셋을 담은 RecordMetadata 객체를 리턴한다.


#### 카프카 프로듀서 요소 개괄
![image](https://github.com/user-attachments/assets/fa4da5b3-e31a-47e4-807e-3a289cdcd7be)


## 3.2 카프카 프로듀서 생성하기 - 필수 속성값 3가지
### bootstrap.servers
 * 프로듀서가 사용할 브로커의 hostLport 목록
 * 모든 브로커를 포함할 필요는 없다. - 첫 연결을 생성한 뒤 추가정보를 받아오기 떄문.
 * 그러나 혹시 브로커 하나가 작동을 정지하는 경우도 있으니, 최소 2개 이상 지정할 것을 권장.

### key.serializer
 * 카프카에 쓸 레코드의 키 값을 직렬화하기 위한 시리얼라이저 클레스 이름.
 * 카프카 브로커는 메시지의 키값, 밸류값으로 바이트 배열을 받는다.
 * 자주 사용되는 타입은 카프카의 client 패키지에 미리 구현되어 있으니, 쓰면 된다.
 * 키 없이 밸류만 보낼때도 설정해줘야 한다. 이땐 VoidSerializer 를 설정할 수 있다.

### value.serializer
 * 키 시리얼라이저와 동일.

### 프로듀서 전송 방법 3가지
 1. fire and forget - 전송 후 성공이나 실패 여부 신경쓰지 않음.
 2. Synchronous send - 카프카 프로듀서는 언제나 비동기적으로 동작. send() 메서드 호출 후 Future 객체를 리턴받으면 get 메서드를 통해 작업 완료 확인 후 다음 메시지 전송
 3. asynchronous sned - 콜백 함수와 함께 send() 메서드 호출

## 3.4 프로듀서 설정하기
### client.id
 * 프로듀서와 그것을 사용하는 애플리케이션을 구분하기 위한 논리적 식별자.
 * 브로커는 프로듀석 ㅏ보내온 메시지를 구분하기 위해 이 값을 사용

### acks
 * 프로듀서가 쓰기 작업 성공을 판단하기 위해 얼마나 많은 파티션 레플리카가 해당 레코드를 받아야 하는지 결정할때 사용.
 * 디폴트는 `ack=1` 리더 파티션이 수신에 성공하면 응답.
 * `ack=0` : 브로커의 응답을 기다리지 않는다.
 * `acks=all` : 모든 in-sync replica에 전달된 뒤에아 브로커로부터 성공했다는 응답을 받는다.

### 3.4.3 메시지 전달 시간
크게 2 구간으로 나눈다.
1. 비동기 호출 ~ 결과 리턴할때까지 걸리는 시간
2. 결과 리턴 ~ 콜백 호출까지 걸리는 시간
이 두 구간에 영향을 미치는 설정 매개변수들

#### max.block.ms
 * 

#### delivery.timeout.ms
 * ㅇㅇ

#### request.timeout.ms
 * 서버로부터 응답을 받기 위해 얼마나 기다릴 것인지 결정. (쓰기 요청 후 전송을 포기하기 까지 대기하는 시간)
 * 재시도 시간이나 실제 전송 이전에 소요된 시간은 포함하지 않는다.

#### dd
 * ㅇㅇ

#### dd
 * ㅇㅇ

#### dd
 * ㅇㅇ

#### dd
 * ㅇㅇ




#### 카프카 프로듀서 내부 메시지 전달 시간을 작업별로 나눈 개념도
![image](https://github.com/user-attachments/assets/4311d26e-f7dd-4a89-94a4-6efc201e2b50)


### 버퍼와 배치의 차이는?
#### 버퍼
 * 메시지를 네트워크로 보내기전 메모리에 임시로 저장하는 공간
 * 버퍼링을 통해 네트워크 호출을 줄이고 효율적인 전송을 가능하게 함.
 * buffer.memory로 설정. 이 메모리를 초과하면 프로듀서가 메시지를 보내기 전까지 블로킹 된다.
   * 여기서 블로킹이란?
   * `프로듀서 애플리케이션이 새로운 메시지를 보내기 위해 대기 상태에 들어간다는 것을 의미합니다. 이 상태에서는 send() 메서드가 호출되더라도 즉시 실행되지 않고, 버퍼 메모리(buffer.memory)가 확보될 때까지 대기`  
 * 전송시점: 버퍼에 충분히 쌓이거나 블로킹 해제 시

#### 배치
 * 같은 파티션으로 향하는 메시지를 한 번에 묶어 전송
 * 파티션 단위로 관리됨.
 * 전송시점: batch.size에 도달하거나 linger.ms 초과시 배치가 전송한다.

#### 프로듀서 메시지 흐름 요약:
1. 프로듀서가 메시지를 생성 → 버퍼에 저장.
2. 버퍼에서 같은 파티션으로 향하는 메시지 묶음 생성 → 배치 형성.
3. 배치가 batch.size에 도달하거나 linger.ms 시간 초과 시 브로커로 전송.

