# 4장 카프카 컨슈머
카프카에서 데이터를 읽는 애플리케이션은 토픽을 구독하고 구독한 토픽들로부터 메시지를 받기 위해 KafkaConsumer를 사용한다.

## 4.1 카프카 컨슈머 : 개념
 * 카프카 컨슈머는 보통 그룹의 일부로서 작동한다.
 * 동일한 컨슈머 그룹에 속한 여러 개의 컨슈머들이 동일한 토픽을 구독할 경우, *각각의 컨슈머는 해당 토픽에서 서로 다른 파티션의 메시지를 받는 것*이다.
 * 하나의 토픽을 구독하는 하나의 컨슈머 그룹에, 파티션 수보다 컨슈머 수가 더 많다면, 컨슈머 몇몇은 유후 상태가 되어 메시지를 받지 못한다.
 * 하나의 컨슈머로 토픽에 들어오는 데이터의 속도를 감다할 수 없을 수도 있기 때문에, 컨슈머를 추가함으로써 단위 컨슈머가 처리하는 파티션의 메시지 수를 분산ㅅ키니느 것이 일반적인 규모 확장 방식이다.
 * 이는 토픽을 생성할 때 파티션 수를 크게 잡아주는 게 좋은 이유이기도 하다.

> 카프카의 주요 디자인 목표 중 하나는 카프카 토픽에 쓰여진 데이터를 전체 조직 안에서 여러 용도로 사용할 수 있도록 만드는 것.
> 이렇게 할려면 애플리케이션이 각자의 컨슈머 그룹을 갖도록 해야한다.

### 4.1.2 컨슈머 그룹과 파티션 리밸런스
 * 새로운 컨슈머를 그룹에 추가하면, 이전에 다른 컨슈머가 읽고 있던 파티션으로부터 메시지를 읽기 시작한다.
 * 컨슈머가 종료되거나 크래시가 났을 경우도 마찬가지.
 * 해당 컨슈머가 그룹을 나가면, 이 컨슈머가 일던 파티션들은 그룹에 잔류한 나머지 컨슈머 중 하나가 대신 받아서 읽기 시작하는 것이다.
 * 컨슈머에 파티션을 재할당 하는 작업은 컨슈머 그룹이 읽고 있는 토픽이 ㅂ녀경되었을 때도 발생한다. (토픽에 새 파티션 추가)
 * 컨슈머에 할당된 파티션을 다른 컨슈머에게 할당해주는 작업을 `리밸런스` 라고 한다.

#### 리밸런스 발생 케이스 정리
 1. 그룹 내 컨슈머 추가 혹은 제거
 2. 파티션 추가
 3. 브로커 수의 변경
 4. 컨슈머 그룹 리밸런싱 트리거 (세션 타임아웃, 오프셋 커밋 타임아웃)
 5. 브로커의 리더 선출 변경
 6. 리밸런스 프로토콜 변경 (Single Group Coordinator vs Cooperative Rebalance)
 7. 일시적인 네트워크 이슈

### 조급한 리밸런스 (Eager Rebalance)
 * 모든 컨슈머는 읽기 작업을 멈추고 자신에게 할당된 모든 파티션에 대한 소유권을 포기한 뒤, 컨슈머 그룹에 다시 참여하여 완전히 새로운 파티션을 할당 받는다.
 * 짧은 시간동안 작업을 멈추는 단점이 있다.

![image](https://github.com/user-attachments/assets/5f65542a-1a71-42d1-a3a8-76a95aa3993b)

### 협력적 리밸런스 (Cooperative Rebalance) 또는 점진적 리밸런스
 * 한 컨슈머에게 할당되어 있던 파티션만을 다른 컨슈머에게 재할당한다.
 * 잴할됭되지 않은 파티션의 컨슈머들은 하던 일을 계속할 수 있는 것이다.
 * 안정적으로 파티션이 할당될때까지 몇번 반복될 수 있지만, stop the world 현상은 발생하지 않는다.

![image](https://github.com/user-attachments/assets/56e66159-2dea-4d72-9d75-a932f49a29a7)

> 2.4 부터 조급한 리밸런스가 디폴트였다가 3.1부터 협력적 리밸런스가 기본값이 되었다.
> 조급한 리밸런스는 추구 삭제 예정이다.

### 컨슈머가 죽었다는 것을 어떻게 알고 리밸런스 하는가?
 * 컨슈머들은 컨슈머 그룹의 그룹 코디네이터 역할을 지정받은 카프카 브로커에 하트비트를 전송함으로써 멤버십과 할당된 파티션에 대한 소유권을 유지한다.
 * 하트비트는 컨슈머의 백그라운드 스레드에 의해 전송된다.
 * 만약 컨슈머가 일정 시간 이상 하트비트를 전송하지 않는다면, 세션 타임아웃이 발생하면서 그룹 코디네이터는 해당 컨슈머가 죽었다고 간주하고 리밸런스를 실행한다.
 * 컨슈머가 깔끔하게 닫아주는 경우, 그룹 코디네이터에 그룹을 나간다고 통지하는데, 그럼 그룹 코디네이터는 그 즉시 리밸런스를 실행한다.

### 파티션은 어떻게 컨슈머에 할당되는가? (w/ 컨슈머 그룹 리더)
 * 컨슈머가 그룹에 찹여하고 싶다고 joinGroup 요청을 보내면, 가장 빨리 그룹에 참여한 컨슈머가 그룹의 리더가 된다.
 * 그룹 리더는 코디네이터로부터 해당 그룹의 컨슈머 목록을 수신받아 각 컨슈머에 파티션을 할당한다.
 * 할당이 완료되면 할당 내역을 그룹 코디네이터에게 전달한 후, 그룹 코디네이터가 이 정보를 모든 컨슈머에게 전파한다.

### 4.1.3 정적 그룹 멤버십
 * 기본적으로 컨슈머 그룹 멤버 자격은 일시적이다.
 * 정적으로 멤버 자격을 유지하라면 `group.instance.id` 를 설정해야 한다.
 * 정적 멤버 컨슈머가 꺼질 경우, 자동으로 그룹을 떠나지 않고, 세션 타임아웃이 경과될 때까지 여전히 그룹 멤버로 남아 있게 된다.
    * 세션 타임아웃 전에 컨슈머가 다시 조인하면 멤버십이 그대로 유지되기 때문에 리밸런스가 발생할 필요없이 에전에 할당받았던 파티션들을 그대로 재할당 받는다.
 * 같은 `group.instance.id`를 갖는 2개의 컨슈머가 같은 그룹에 조인하면, 두번째 조인한 컨슈머에게 이미 컨슈머가 존재한다는 에러가 발생한다.
 * 세션 타임아웃 값은 `session.timeout.ms` 설정에 따르는데,
   * 단순 애플리케이션 재시작이 리밸런스를 작동시키지 않을 만큼 크게 설정할 필요가 있고,
   * 시간(?) 동안 작동이 멈출 경우 자동으로 파티션 재할당이 이루어져서 오랫동안 파티션 처리가 멈추는 상황을 막을 수 있을만큼 작게 설정할 필요가 있다.


## 4.4 폴링 루프
 * 컨슈머는 단순 폴링을 무한 루프로 반복하는 구조다.
 * `consumer.poll(timeout_ms)` timeout 매개변수는 컨슈머 버퍼에 데이터가 없을 경우 poll() 메서드가 블록될 수 있는 최대시간을 결정한다.
 * poll() 메서드는 레코드들이 저장한 List 객체를 리턴한다.
 * 각 레코드는 토픽, 파티션, 파티션에서의 오프셋 그리고 당연하게도 키값과 밸류값을 포함한다.
 * poll()은 생각보다 많은 일을 한다.
    * 그룹 코디네이터를 찾아서 컨슈머 그룹에 참가하고, 파티션을 할당 받고, 리밸런스와 연관된 콜백도 처리한다. 따라서
 * `max.poll.interval.ms` 지정된 시간 이상으로 호출되지 않을 경우, 컨슈머는 죽은 것으로 판정되어 그룹에서 퇴출된다.

### 4.4.1 스레드 안정성
 * 하나의 스레드당 하나의 컨슈머, 이것이 원칙이다.
 * 여러 컨슈머를 운용하려면 여러 스레드를 띄워서 하나씩 돌려야 한다.
 * 아니면 이벤트를 받아서 큐에 넣는 컨슈머 하나와 이 큐에서 이벤트를 꺼내서 처리하는 여러 개의 워커 스레드를 사용하는 것이다.

#### 예전버전 poll(long) vs 새 버젼 poll(Duration)
 * 예전 버젼에서는 메타데이터를 가져올때까지 블록된다. 설령 타임아웃 시간보다 길어도
 * 신규 버젼에서는 메타데이터가 올때까지 기다리지 않는다. 타임아웃을 엄격히 지킨다.
 * 즉 poll(0) 과 poll(Duration.millies(0)) 의 결과는 다를 수 있다.

## 4.5 컨슈머 설정하기

 * `fetch.min.bytes` : 컨슈머가 브로커로부터 레코드를 얻어올 때 받는 데이터의 최소량. (디폴트 1바이트) 이 값보다 작으면 브로커는 기다린다.
 * `fetch.max.wait.ms` : 카프카가 컨슈머에게 응답하기 전 충분한 데이터 모일때까지 기다리는 최대 시간. (디폴트 500ms)
> 브로커는 `fetch.min.bytes` 이상 데이터가 모이거나, `fetch.max.wait.ms` 시간이 지나면 데이터를 보낸다.

 * `fetch.max.bytes` : 컨슈머가 브로커를 폴링할때 받을 수 있는 최대 바이트 수 (디폴트 50MB) 컨슈머가 서버버로 부터 받은 데이터를 저장하기 위해 사용하는 메모리 양을 제한하기 위해 사용
Q 95p) 만약 브로커가 보내야 하는 첫 번째 레코드 배치의 크기가 이 설정값을 넘길 경우, 제한 값을 무시하고 해당 배치를 그대로 전송한다. ??
 
 * `max.poll.records` : poll 호출시 리턴되는 최대 레코드 수.
 * `max.partition.fetch.bytes` : 파티션별로 리턴하는 최대 바이트 수 (디폴트 1MB)
 * `hearbeat.interval.ms` : 얼마나 자주 그룹 코디네이터에게 하트비트를 보낼 정하는 주기. `session.timeout.ms` 보다 작은 값이어야 한다. 대체로 1/3 (디폴트 3초)
 * `session.timeout.ms` : 하트비트가 이 시간동안 아오면 죽은것으로 간주하여 리밸런스를 실행시킨다. (디폴트 10초 -> 45초)
    * 2.8버젼 디폴트 10초, 3.10부터 45초로 변경 - 이는 클라우드 환경에선 순간적인 부하집중과 네트워크 불안정으로 인한 리밸랜스 발생을 막기 위함.
 * `max.poll.interval.ms` : 이 시간동안 컨슈머가 폴링하지 않으면 죽었다고 판단. (하트비트와 독립적으로 동작) (디폴트 5분, 정상 동작중인 컨슈머가 데이터 처리로 늦은 폴링일 수 있으니 이러한 케이스를 방지하기 위해 충분히 큰 값이어야 한다.)
 * `default.api.timeout.ms` : 명시적인 타임아웃 지정하지 않은 API 타임아웃 (디폴트 1분), poll은 timeout이 필수이므로 이 설정에 영향받지 않는다.
 * `request.timeout.ms` : 컨슈머가 브로커로부터 응답을 기다릴 수 있는 최대 시간 (디폴트 30초, 더 내리지 않는 것을 권장.) 이 시간까지 응답하지 않으면 연결을 닫은 뒤 재연결을 시도한다.
 * `auto.offset.reset` : 오프셋 커밋을 잃은 경우, 파티션을 어느 시점부터 읽을지 결정. (디폴트 latest), earlist, none 이 있는데, none은 유효하지 않은 오프셋을 읽으려할때 예외 발생.
 * `enable.auto.commit` : 오프셋 커밋을 컨슈머가 자동으로 할지 결정 (디폴트 true) true 인 경우, `auto.commit.interval.ms` 사용해서 얼마나 자주 오프셋이 커밋될지 제어
 * `partition.assignment.strategy` : 컨슈머들에 파티션을 어떻게 할당할지 결정.
   * `Range` : 컨슈머가 구독하는 각 토픽의 파티션들을 연속된 그룹으로 나눠서 할당. 첫 컨슈머는 두번째 컨슈머보다 더 많은 파티션을 할당받는다.
   * `RoundRobin` : 순차적으로 하나씩 할당
   * `sticky` : 기본적으로 RoundRobin 이지만, 리밸런스 발생시 가능하면 많은 파티션들이 같은 컨슈머에 할당되게 함.
   * `Cooperative sticky` : sticky와 기본적으로 동일하지만, 컨슈머가 재할당되지 않은 파티션으로부터 레코드를 계속해서 읽어올 수 있도록 해주는 협력적 리밸런스 기능을 지원한다. (2.3 이전 버젼에서는 업그레이드 주의)
 * `client.id` : 브로커가 요청을 보낸 클라이언트를 식별
 * `client.rack` : 데이터센터가 여러개 일 경우, 같은 영역의 레플리카로부터 메시지를 읽어오게 하는 설정. 설정 후 `replica.selector.class` 설정 기본값을 `org.apache.kafka.common.replica.RackAwareReplicaSelector`로 잡아주면 된다.
 * `group.instance.id` : 정적 그룹 멤버십 기능
 * `receive.buffer.bytes`, `send.buffer.bytes` : 데이터 읽거나 쓸때 소켓이 사용하는 tcp 수신 및 발신 버퍼의 크기
 * `offset.retention.minutes` : 브로커 설정이지만 컨슈머 작동에도 큰 영향. 그룹이 비게 되면 카프카는 이 설정값 기간동안만 오프셋 정보를 저장한다. (디폴트 7일) 이 옵션은 작동 방식이 여러번 바뀌었으므로 2.1.0 이전은 공식문서 확인이 필요하다.

## 4.6 오프셋과 커밋
 * 기본적으로 레코드를 개별적으로 커밋하지 않고, 마지막 메시지를 커밋함으로써 그 앞의 모든 메시지들도 역시 성공처리 되었음을 암묵적으로 나타낸다.
 * 카프카 특수포틱인 `__consumer_offsets` 토픽으로 각 파티션별 커밋된 오프셋을 업데이트한다.
### 자동 커밋
 * 5초에 한번 poll로 받은 메시지 중 가장 마지막 메시지의 오프셋을 커밋한다.
 * 5초는 `auto.commit.interval.ms` 설정으로 변경 가능
 * poll 후 자동 커밋 주기인 5초가 되기전에 컨슈머가 크래시되면, 오프셋 업데이트가 되지 않아서, 메시지 중복이 발생할 수 밖에 없다.
### 특정 오프셋 커밋
 * commitSync, commitAsync 호출할때 커밋하고자하는 파티션과 오프셋의 맵을 전달할 수 있다.


## 4.7 리밸런스 리스너
 * 컨슈머는 종료전이나 리밸런스 시작전에 정리 작업(cleanup)을 해줘야 한다.
   * 처리된 마지막 오프셋을 커밋하거나 db 커넥션 등을 닫아줘야 한다.
 * subscribe() 호출할때 ConsumerReblanceListener 전달해주면 3가지 메서드를 구현할 수 있다.
### onPartitionsAssigned()
 * 컨슈머 재할당 후 하지만 메시지 읽기전 호출된다.
 * 여기서 수행되는 모든 준비 작업은 max.poll.timeout.ms 안에 완료되어야 한다.
### onPartitionsRevoked()
 * 파티션 할당이 해제될때 호출된다.
   * 조급한 리밸런스 알고리즘일땐, 컨슈머가 메시지 읽기 멈춘 뒤 리밸런스 시작 전
   * 협력적 리밸런스 일땐, 컨슈머에서 할당 해제되어야 할 파티션들에 대해서만 호출된다. 여기서 오프셋을 커밋해주어야 이 파티션을 다음 할당받는 컨슈머가 시작할 지점을 알 수 있다.
### onPartitionsLost()
 * 협력적 리밸런스 일떄 ,할당된 파티션이 리밸런스에 의해 해제되기 전에 다른 컨슈머에 먼저 할당된 예외적인 상황에서만 호출된다.
 * 이 메서드를 구현하지 않았을 경우, onPartitionsRevoked가 대신 호출된다.

## 4.8 특정 오프셋 레코드 읽기
 * 파티션의 맨 앞부터 읽고자 한다면, seekToBeginning(), 새로 들어온 메시지 부터 읽기 시작하고자 한다면 seekToEnd()
 * 특정 오프셋으로 탐색하갈수도 있다. seek() 메서드 : 오프셋을 재설정해준다.

## 4.9 폴링 루프를 벗어나는 방법
 * 다른 스레드에서 consumer.wakeup() 호출해줘야 한다. 그럼 poll 호출될때 예외가 발생한다. 이때 스레드 종료전 consumer.close 호출해줘야 한다.
 * 메인 스레드에서 컨슈머 루프가 돌고 있다면 ShutDownHook을 사용할 수 있다. ??

## 4.11 독립 실행 컨슈머 : 그룹 없이 사용
 * 그냥 컨슈머에게 특정 토픽과 파티션을 할당해주고, 메시지를 읽어서 처리하고, 필요할 경우 오프셋을 커밋하면 된다.
 * 토픽 구독없이 근야 파티션 할당 받으면 된다. consumer.partitionsFor("topic");
 * 누군가 토픽에 새로운 파티션을 추가할 경우 컨슈머에게 알림이 오지 않는다..! 주기적으로 partitionsFor 메서드를 호출해서 파티션 정보를 확인해야 한다.

