# 4장 카프카 컨슈머
카프카에서 데이터를 읽는 애플리케이션은 토픽을 구독하고 구독한 토픽들로부터 메시지를 받기 위해 KafkaConsumer를 사용한다.

## 4.1 카프카 컨슈머 : 개념
 * 카프카 컨슈머는 보통 그룹의 일부로서 작동한다.
 * 동일한 컨슈머 그룹에 속한 여러 개의 컨슈머들이 동일한 토픽을 구독할 경우, *각각의 컨슈머는 해당 토픽에서 서로 다른 파티션의 메시지를 받는 것*이다.
 * 하나의 토픽을 구독하는 하나의 컨슈머 그룹에, 파티션 수보다 컨슈머 수가 더 많다면, 컨슈머 몇몇은 유후 상태가 되어 메시지를 받지 못한다.
 * 하나의 컨슈머로 토픽에 들어오는 데이터의 속도를 감다할 수 없을 수도 있기 때문에, 컨슈머를 추가함으로써 단위 컨슈머가 처리하는 파티션의 메시지 수를 분산ㅅ키니느 것이 일반적인 규모 확장 방식이다.
 * 이는 토픽을 생성할 때 파티션 수를 크게 잡아주는 게 좋은 이유이기도 하다.

> 카프카의 주요 디자인 목표 중 하나는 카프카 토픽에 쓰여진 데이터를 전체 조직 안에서 여러 용도로 사용할 수 있도록 만드는 것.
> 이렇게 할며ㅕㄴ 애플리케이션이 각자의 컨슈머 그룹을 갖도록 해야한다.

### 4.1.2 컨슈머 그룹과 파티션 리밸런스
 * 새로운 컨슈머를 그룹에 추가하면, 이전에 다른 컨슈머가 읽고 있던 파티션으로부터 메시지를 읽기 시작한다.
 * 컨슈머가 종료되거나 크래시가 났을 경우도 마찬가지.
 * 해당 컨슈머가 그룹을 나가면, 이 컨슈머가 일던 파티션들은 그룹에 잔류한 나머지 컨슈머 중 하나가 대신 받아서 읽기 시작하는 것이다.
 * 컨슈머에 파티션을 재할당 하는 작업은 컨슈머 그룹이 읽고 있는 토픽이 ㅂ녀경되었을 때도 발생한다. (토픽에 새 파티션 추가)
 * 컨슈머에 할당된 파티션을 다른 컨슈머에게 할당해주는 작업을 `리밸런스` 라고 한다.

#### 리밸런스 발생 케이스 정리
 1. 그룹 내 컨슈머 추가 혹은 제거
 2. 파티션 추가
 3. 브로커 수의 변경
 4. 컨슈머 그룹 리밸런싱 트리거 (세션 타임아웃, 오프셋 커밋 타임아웃)
 5. 브로커의 리더 선출 변경
 6. 리밸런스 프로토콜 변경 (Single Group Coordinator vs Cooperative Rebalance)
 7. 일시적인 네트워크 이슈

### 조급한 리밸런스 (Eager Rebalance)
 * 모든 컨슈머는 읽기 작업을 멈추고 자신에게 할당된 모든 파티션에 대한 소유권을 포기한 뒤, 컨슈머 그룹에 다시 참여하여 완전히 새로운 파티션을 할당 받는다.
 * 짧은 시간동안 작업을 멈추는 단점이 있다.

![image](https://github.com/user-attachments/assets/5f65542a-1a71-42d1-a3a8-76a95aa3993b)

### 협력적 리밸런스 (Cooperative Rebalance) 또는 점진적 리밸런스
 * 한 컨슈머에게 할당되어 있던 파티션만을 다른 컨슈머에게 재할당한다.
 * 잴할됭되지 않은 파티션의 컨슈머들은 하던 일을 계속할 수 있는 것이다.
 * 안정적으로 파티션이 할당될때까지 몇번 반복될 수 있지만, stop the world 현상은 발생하지 않는다.

![image](https://github.com/user-attachments/assets/56e66159-2dea-4d72-9d75-a932f49a29a7)

> 2.4 부터 조급한 리밸런스가 디폴트였다가 3.1부터 협력적 리밸런스가 기본값이 되었다.
> 조급한 리밸런스는 추구 삭제 예정이다.

### 컨슈머가 죽었다는 것을 어떻게 알고 리밸런스 하는가?
 * 컨슈머들은 컨슈머 그룹의 그룹 코디네이터 역할을 지정받은 카프카 브로커에 하트비트를 전송함으로써 멤버십과 할당된 파티션에 대한 소유권을 유지한다.
 * 하트비트는 컨슈머의 백그라운드 스레드에 의해 전송된다.
 * 만약 컨슈머가 일정 시간 이상 하트비트를 전송하지 않는다면, 세션 타임아웃이 발생하면서 그룹 코디네이터는 해당 컨슈머가 죽었다고 간주하고 리밸런스를 실행한다.
 * 컨슈머가 깔끔하게 닫아주는 경우, 그룹 코디네이터에 그룹을 나간다고 통지하는데, 그럼 그룹 코디네이터는 그 즉시 리밸런스를 실행한다.

### 파티션은 어떻게 컨슈머에 할당되는가? (w/ 컨슈머 그룹 리더)
 * 컨슈머가 그룹에 찹여하고 싶다고 joinGroup 요청을 보내면, 가장 빨리 그룹에 참여한 컨슈머가 그룹의 리더가 된다.
 * 그룹 리더는 코디네이터로부터 해당 그룹의 컨슈머 목록을 수신받아 각 컨슈머에 파티션을 할당한다.
 * 할당이 완료되면 할당 내역을 그룹 코디네이터에게 전달한 후, 그룹 코디네이터가 이 정보를 모든 컨슈머에게 전파한다.

### 4.1.3 정적 그룹 멤버십
 * 기본적으로 컨슈머 그룹 멤버 자격은 일시적이다.
 * 정적으로 멤버 자격을 유지하라면 `group.instance.id` 를 설정해야 한다.
 * 정적 멤버 컨슈머가 꺼질 경우, 자동으로 그룹을 떠나지 않고, 세션 타임아웃이 경과될 때까지 여전히 그룹 멤버로 남아 있게 된다.
    * 세션 타임아웃 전에 컨슈머가 다시 조인하면 멤버십이 그대로 유지되기 때문에 리밸런스가 발생할 필요없이 에전에 할당받았던 파티션들을 그대로 재할당 받는다.
 * 같은 `group.instance.id`를 갖는 2개의 컨슈머가 같은 그룹에 조인하면, 두번째 조인한 컨슈머에게 이미 컨슈머가 존재한다는 에러가 밸상ㅇ한다.
 * 세션 타임아웃 값은 `session.timeout.ms` 설정에 따르는데,
   * 단순 애플리케이션 재시작이 리밸런스를 작동시키지 않을 만큼 크게 설정할 필요가 있고,
   * 시간(?) 동안 작동이 멈출 경우 자동으로 파티션 재할당이 이루어져서 오랫동안 파티션 처리가 멈추는 상황을 막을 수 있을만큼 작게 설정할 필요가 있다.


## 4.4 폴링 루프
 * 컨슈머는 단순 폴링을 무한 루프로 반복하는 구조다.
 * `consumer.poll(timeout_ms)` timeout 매개변수는 컨슈머 버퍼에 데이터가 없을 경우 poll() 메서드가 블록될 수 있는 최대시간을 결정한다.
 * poll() 메서드는 레코드들이 저장한 List 객체를 리턴한다.
 * 각 레코드는 토픽, 파티션, 파티션에서의 오프셋 그리고 당연하게도 키값과 밸류값을 포함한다.
 * poll()은 생각보다 많은 일을 한다.
    * 그룹 코디네이터를 찾아서 컨슈머 그룹에 참가하고, 파티션을 할당 받고, 리밸런스와 연관된 콜백도 처리한다. 따라서
 * `max.poll.interval.ms` 지정된 시간 이상으로 호출되지 않을 경우, 컨슈머는 죽은 것으로 판정되어 그룹에서 퇴출된다.

### 4.4.1 스레드 안정성
 * 하나의 스레드당 하나의 컨슈머, 이것이 원칙이다.
 * 여러 컨슈머를 운용하려면 여러 스레드를 띄워서 하나씩 돌려야 한다.
 * 아니면 이벤트를 받아서 큐에 넣는 컨슈머 하나와 이 큐에서 이벤트를 꺼내서 처리하는 여러 개의 워커 스레드를 사용하는 것이다.

#### 예전버전 poll(long) vs 새 버젼 poll(Duration)
 * 예전 버젼에서는 메타데이터를 가져올때까지 블록된다. 설령 타임아웃 시간보다 길어도
 * 신규 버젼에서는 메타데이터가 올때까지 기다리지 않는다. 타임아웃을 엄격히 지킨다.
 * 즉 poll(0) 과 poll(Duration.millies(0)) 의 결과는 다를 수 있다.

## 4.5 컨슈머 설정하기

 * `fetch.min.bytes` : 컨슈머가 브로커로부터 레코드를 얻어올 때 받는 데이터의 최소량. 디폴트 1바이트. 이 값보다 작으면 브로커는 기다린다.
 * `fetch.max.wait.ms` : 카프카가 컨슈머에게 응답하기 전 충분한 데이터 모일때까지 기다리는 최대 시간. 디폴트 500ms.
> 브로커는 `fetch.min.bytes` 이상 데이터가 모이거나, `fetch.max.wait.ms` 시간이 지나면 데이터를 보낸다.

 * `fetch.max.bytes`
 * `max.poll.records`
 * `max.partition.fetch.bytes` 
 * `session.timeout.ms`, `hearbeat.interval.ms`
 * `max.poll.interval.ms`
 * `default.api.timeout.ms`
 * `request.timeout.ms`
 * `auto.offset.reset`
 * `enable.auto.commit`
 * `partition.assignment.strategy`
 * `client.id`
 * `client.rack`
 * `group.instance.id` : 정적 그룹 멤버십 기능
 * `receive.buffer.bytes`, `send.buffer.bytes`
 * `offset.retention.minutes`






