### 퀴즈
 * 카프카 표준 헤더에 포함되는 정보는?
 * 'Not a leader for partition' 은 언제 받는 로그인가?
 * 클라이언트는 리더 파티션이 있는 브로커를 어떻게 알까?
 * 파티션 리더 레플리카가 쓰기 요청 받으면 하는 유효성 검사는?
 * 퍼거토리란? (빼자)
 * 모든 인싱크 레플리카에 쓰여진 메시지만 클라이언트가 읽을 수 있도록 제한하는 이유는?
(6.4까지)
  * 파티션은 서로 다른 브로커들 사이에 분리될 수 없으며 같은 브로커의 서로 다른 디스크에 분할 저장되는 것은 가능하다. (O/X)
  * 파티션 할당 목표 3가지
  * 새 파티션이 저장할 디렉토리를 결정할때는, 각 디렉토리에 저장된 파티션들의 공간을 계산한 뒤, 가장 공간이 넓은 디렉토리에 새 파티션이 저장된다.  (O/X)

Q) 압착 후 삭제는 언제하는가?


---

  
### 퀴즈와 정답
 * 카프카 표준 헤더에 포함되는 정보는?
    * 요청 유형, 요청 버젼, Correlation ID, 클라이언트 ID
 * 'Not a leader for partition' 은 언제 받는 로그인가?
   * 다른 브로커가 리더를 맡고 있는 파티션에 쓰기 요청을 한 경우
 * 클라이언트는 리더 파티션이 있는 브로커를 어떻게 알까?
   * 메타데이터 요청이라 불리는 또 다른 요청을 사용한다.
     * 클라이언트는 다루고자 하는 토픽들의 목록을 포함하여 요청한다.
     * 그럼 서버는 해당 토픽들에 어떤 파티션, 레플리카는 무엇이고, 어떤 레플리카가 리더인지 명시하는 응답을 리턴한다.
     * 아무 브로커에나 보내도 되고 모든 브로커는 이 정보를 포함하는 메터데이터 캐시를 가지고 있다.
     * 클라이언트는 보통 이 정보를 캐시해두는데,
        * 최신값 유지를 위한 새로고침 기한을 metadata.max.age.ms 설정으로 조정한다.
        * 혹은 'Not a leader for partition' 를 받은 경우 새로고침 한다.
 * 파티션 리더 레플리카가 쓰기 요청 받으면 하는 유효성 검사는?
    * 쓰기 권한이 있는가.
    * ack 설정이 올바른가
    * ack=all 인 경우, 메시지를 안전하게 쓸 수 있을 만큼 충분한 인-싱크 레플리카가 있는가.
 * 퍼거토리란?
    * 지연된 응답들은 완료될 때까지 퍼거토리에 저장된다.
      * ack=all 인 경우, 모든 팔로워 레플리카가 메시지를 복제한 것을 확인한 다음에야 클라이언트에 응답을ㄹ 돌려보낸다.
(6.4까지)
 * 파티션 저장 경로 설정과 에러로그 디렉토리는 어떻게 설정하는가?
   * 파티션은 서로 다른 브로커들 사이에 분리될 수 없으며 같은 브로커의 서로 다른 디스크에 분할 저장되는 것 조차 불가능하다.
   * 따라서 파티션의 크기는 마운트 지점에 사용 가능한 공간에 재한 받는다.
   * 파티션 저장 디렉토리 목록은 lig.dirs 매개변수에 저장된다.
   * 에러 로그 디렉토리는 log4j.properties 파일에 저장된다.
 * 파티션 할당 목표 3가지
    * 레플리카들을 가능한 브로커 간 고르게 분산
    * 각 레플리카는 서로 다른 브로커에 배치
    * 브로커에 랙 정보가 설정되어 있다면, 레플라카들을 서로 다른 랙에 할당
 * 새 파티션이 저장할 디렉토리를 결정하는 과정은?
    * 각 디렉토리에 저장되어 있는 파티션읠 수를 센 뒤, 가장 적은 파티션이 저장된 디렉토리에 새 파티션을 저장한다.  
 * 압착 작동 원리
   * 이전에 압착되어 정리 작업이된 메시지를 '클린', 클린되지 않은 새롭게 쓰여진 메시지를 '더티'영역이라고 한다.
   * 압착 기능은 log.cleaner.enabled 설정에서 지정가능하다.
   * 각 브로커는 압착 매니터 스레드와 다수의 압착 스레드가 있고, 압착 작업은 이 스레드들이 담당한다.
   * 파티션 크기 대비 더티 메시지 비율이 가장 높은 파티션부터 압착하여 클린 상태로 만든다.
   * 인메모리 맵을 생성하고, 맵의 각 항목은 16바이트 해시와 8바이트의 메시지 오프셋으로 이뤄져서 24바이트만 사용한다
 * 가장 최근 메시지조차 남기지 않고 시스템에서 특정 키를 완전히 삭제하려면, 해당 키 값과 null 밸류를 갖는 메시지를 써주면 된다.
 * 압착 시작 시점 조절
   * min.compaction.lag.ms 메시지가 쓰여진 뒤 압착될대까지 나가야하는 최소 시간
   * max.compaction.lag.ms 메시지가 쓰여진 뒤 압착이 가능해질때까지 딜레이될 수 잇는 최대 시간.  



---
  
# 6장

## 클러스터 멤버십
 * 카프카는 현재 클러스터의 멤버인 브로커들의 목록을 유지하기 위해 아파치 주키퍼를 사용한다.
 * 각 브로커는 브로커 설정 파일에 정의되었거나 아니면 자동으로 생성된 고유한 식별자를 가진다
 * 브로커 프로세스는 시작될때마다 주키퍼에 Ephemeral 노드의 형태로 ID를 등록한다.
 * 컨트롤러를 포함한 카프카 브로커들과 몇몇 생테계 툴들은 브로커가 등록되는 주키퍼의 /brokers/ids 경로를 구독함으로써 브로커가 추가되거나 제거될때마다 알림을 받는다.
 * 브로커와 주키퍼 간의 연결이 끊어질 경우, 브로커 시작시 생성한 노드는 자동으로 주키퍼에서 삭제된다. 이 목록을 지켜보던 다른 컴포넌트들도 해당 브로커가 내려갔음을 인지한다.
 * 브로커가 정지하면 브로커를 나타내는 ZNode 역시 삭제되지만, 브로커의 ID는 다른 자료구조에 남아있게 된다.
   * 하나의 브로커가 완전히 유실되어 동일 ID 가진 새로운 브로커 투입할 경우, 곧바로 클러스터에서 유실된 브로커의 자리를 대신해서 이전 브로커의 토픽과 파티션들을 할당받는다.
  
## 6.2 컨트롤러
 * ?
 * 새로운 컨트롤러가 선출될때마다 주키퍼의 조건적 증가 연상에 의해 증가된 epoch 값을 전달받게 된다.
    * 이 값을 컨트롤러가 전송하는 메시지에 포함한다.
    * 브로커는 이 값을 통해 현재 컨트롤러가 좀비인지 판단한다. (좀비 컨트롤러 방지)

### 6.2.1 KRaft
 * ㅇㅇ
 * 컨트롤러는 다른 브로커에 변경사항을 push 하지 않는다. 다른 브로커들이 새로 도입된 MetadataFetch API를 사용해서 액티브 컨트롤러로부터 변경사항을 pull 해온다.
   * 컨슈머 읽기 요청과 유사하게, 브로커는 마지막으로 가져온 메타데이터 변경 사항의 오프셋을 추적하고, 그 보다 나중 업데이트만 컨트롤러에 요청한다.
     * 추후 시동 시간 줄이기 위해 메타데이터를 디스크에 저장해준다.
 * 브로커 프로세스는 시작시 주키퍼가 아닌, 컨트롤러 쿼럼에 등록한다. 브로커가 종료되면 오프라인 상태로 들어가는 것일 뿐 등록은 여전히 유지된다.
 * 온라인 상태지만 최신 메타데이터를 유지하지 않는 브로커는 펜스 상태가 되어 클라이언트 요청을 처리할 ㅅ ㅜ없다.

## 6.3 복제
 * 모든 쓰기 요청은 리더에게
 * 클라이언트는 리더 혹은 팔로워로부터 레코드를 읽어올 수 있다.
 * 리더 레플리카의 또 다른 일은 어느 팔로워 레플리카가 리더 레플리카의 최신 상태를 유지하고 있는지 확인하는 것이다.
 * 팔로워 레플리카는 리더 레플리카와 동기화를 유지하기 위해 읽기 요청을 보내는데, 이 요청은 컨슈머가 메시지를 읽어오기 위해 사용하는 그 요청이다.
   * 리더 레플리카는 이 요청을 통해 팔로워 레플리카들의 동기화 상태를 확인할 수 있다.
   * 동기화가 유지된 팔로워만이 리더 장애 발생시 리더로 선출될 수 있다.
 * 팔로워 레플리카가 동기화가 풀린 것으로 판정될 때까지 걸리는 시간은 replica.lag.time.max.ms 로 설정할 수 있다.
 * 현재 리더에 더하여, 각 파티션은 선호 리더를 갖는다.
   * 선호 리더는 토픽 생성시 리더 레플리카였던 레플리카를 가리킨다.
   * 파티션 생성 시점에는 모든 브로커에 균등하게 리더가 분포 되기 때문에 선호 리더를 가진다.
   * auto.leader.rebalance.enable=true 설정이 잡혀있으면,
      * 선호 리더가 현재 리더가 아니지만, 현재 리더와 동기화가 되어 있을 경우, 리더 선출을 실행시켜서 선호 리더를 현재 리더로 만들어준다.

## 6.4 요청처리
### 처리 과정
 * 브로커는 연결 받는 각 포트별로 억섹터 스레드를 하나씩 실행시킨다.
 * 억섹터 스레드는 연결을 생성하고 들어온 요청을 프로세서 스레드에 넘긴다.
 * 프로세서 스레드는 요청을 받아 요청 큐에 넣는다. 혹은 응답 큐에서 응답을 꺼내서 클라이언트에 보낸다.
   * 가끔은 클라이언트로 보낼 응답에 지연이 필요할 때가 있다.
   * 지연된 응답들은 완료될 때까지 퍼거토리에 저장된다. 
 * I/O 스레드는 요청 큐의 요청을 하나씩 꺼내서 실제 처리한 후 응답 큐에 넣는다.


### 쓰기 요청


### 읽기 요청
 * 클라이언트의 요청이 오면 유효성 검사부터 한다. - 지정된 오프셋이 해당 파티션에 존재하는지)
 * 제로카피 최적화 : 파일에서 일겅온 메시지들을 중간 버퍼를 거치지 않고 바로 네트워크 채널로 보낸다. (대부분의 DB들과의 차이점)
    * 오버헤드가 사라지며 성능이 향상된다.
 * 클라이언트는 모든 인-싱크 레플리카에 쓰여진 메시지들만 읽을 수 있다.
    * 크래시 상황이 발생하면 메시지의 일관성이 결여될 수 있기 때문이다.
    * 브로커 사이 복제가 너무 늦어지는 상황을 대비하기 위해 replica.lag.time.max.ms 설정으로 지연을 제한한다.
    * 이 시간 이상 지나면 아웃오브싱크 레플리카가 된다.

### 기타 요청
 * 예전엔 클라이언트가 오프셋을 기록하기 위해 주키퍼 사용했지만 지금은 오프셋 저장용 카프카 토픽을 사용한다.
 * 클라이언트가 업데이트를 하기 전에 브로커들을 먼저 업그레이드 하길 권장하는 이유
    * 새 브로커는 예전 요청을 처리할 수 있지만, 그 반대는 아니다. 





