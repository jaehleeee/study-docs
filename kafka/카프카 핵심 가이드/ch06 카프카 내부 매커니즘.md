### 퀴즈
 * 카프카 표준 헤더에 포함되는 정보는?
 * 'Not a leader for partition' 은 언제 받는 로그인가?
 * 클라이언트는 리더 파티션이 있는 브로커를 어떻게 알까?
 * 파티션 리더 레플리카가 쓰기 요청 받으면 하는 유효성 검사는?
 * 퍼거토리란? (빼자)
 * 모든 인싱크 레플리카에 쓰여진 메시지만 클라이언트가 읽을 수 있도록 제한하는 이유는?
(6.4까지)

---

  
### 퀴즈와 정답
 * 카프카 표준 헤더에 포함되는 정보는?
    * 요청 유형, 요청 버젼, Correlation ID, 클라이언트 ID
 * 'Not a leader for partition' 은 언제 받는 로그인가?
   * 다른 브로커가 리더를 맡고 있는 파티션에 쓰기 요청을 한 경우
 * 클라이언트는 리더 파티션이 있는 브로커를 어떻게 알까?
   * 메타데이터 요청이라 불리는 또 다른 요청을 사용한다.
     * 클라이언트는 다루고자 하는 토픽들의 목록을 포함하여 요청한다.
     * 그럼 서버는 해당 토픽들에 어떤 파티션, 레플리카는 무엇이고, 어떤 레플리카가 리더인지 명시하는 응답을 리턴한다.
     * 아무 브로커에나 보내도 되고 모든 브로커는 이 정보를 포함하는 메터데이터 캐시를 가지고 있다.
     * 클라이언트는 보통 이 정보를 캐시해두는데,
        * 최신값 유지를 위한 새로고침 기한을 metadata.max.age.ms 설정으로 조정한다.
        * 혹은 'Not a leader for partition' 를 받은 경우 새로고침 한다.
 * 파티션 리더 레플리카가 쓰기 요청 받으면 하는 유효성 검사는?
    * 쓰기 권한이 있는가.
    * ack 설정이 올바른가
    * ack=all 인 경우, 메시지를 안전하게 쓸 수 있을 만큼 충분한 인-싱크 레플리카가 있는가.
 * 퍼거토리란?
    * 지연된 응답들은 완료될 때까지 퍼거토리에 저장된다.
      * ack=all 인 경우, 모든 팔로워 레플리카가 메시지를 복제한 것을 확인한 다음에야 클라이언트에 응답을ㄹ 돌려보낸다.
(6.4까지)


---
  
# 6장

## 클러스터 멤버십
 * 카프카는 현재 클러스터의 멤버인 브로커들의 목록을 유지하기 위해 아파치 주키퍼를 사용한다.
 * 각 브로커는 브로커 설정 파일에 정의되었거나 아니면 자동으로 생성된 고유한 식별자를 가진다
 * 브로커 프로세스는 시작될때마다 주키퍼에 Ephemeral 노드의 형태로 ID를 등록한다.
 * 컨트롤러를 포함한 카프카 브로커들과 몇몇 생테계 툴들은 브로커가 등록되는 주키퍼의 /brokers/ids 경로를 구독함으로써 브로커가 추가되거나 제거될때마다 알림을 받는다.
 * 브로커와 주키퍼 간의 연결이 끊어질 경우, 브로커 시작시 생성한 노드는 자동으로 주키퍼에서 삭제된다. 이 목록을 지켜보던 다른 컴포넌트들도 해당 브로커가 내려갔음을 인지한다.
 * 브로커가 정지하면 브로커를 나타내는 ZNode 역시 삭제되지만, 브로커의 ID는 다른 자료구조에 남아있게 된다.
   * 하나의 브로커가 완전히 유실되어 동일 ID 가진 새로운 브로커 투입할 경우, 곧바로 클러스터에서 유실된 브로커의 자리를 대신해서 이전 브로커의 토픽과 파티션들을 할당받는다.
  
## 6.2 컨트롤러

### 6.2.1 KRaft

## 6.3 복제
 * 모든 쓰기 요청은 리더에게
 * 클라이언트는 리더 혹은 팔로워로부터 레코드를 읽어올 수 있다.
 * 리더 레플리카의 또 다른 일은 어느 팔로워 레플리카가 리더 레플리카의 최신 상태를 유지하고 있는지 확인하는 것이다.
 * 팔로워 레플리카는 리더 레플리카와 동기화를 유지하기 위해 읽기 요청을 보내는데, 이 요청은 컨슈머가 메시지를 읽어오기 위해 사용하는 그 요청이다.
   * 리더 레플리카는 이 요청을 통해 팔로워 레플리카들의 동기화 상태를 확인할 수 있다.
   * 동기화가 유지된 팔로워만이 리더 장애 발생시 리더로 선출될 수 있다.
 * 팔로워 레플리카가 동기화가 풀린 것으로 판정될 때까지 걸리는 시간은 replica.lag.time.max.ms 로 설정할 수 있다.
 * 현재 리더에 더하여, 각 파티션은 선호 리더를 갖는다.
   * 선호 리더는 토픽 생성시 리더 레플리카였던 레플리카를 가리킨다.
   * 파티션 생성 시점에는 모든 브로커에 균등하게 리더가 분포 되기 때문에 선호 리더를 가진다.
   * auto.leader.rebalance.enable=true 설정이 잡혀있으면,
      * 선호 리더가 현재 리더가 아니지만, 현재 리더와 동기화가 되어 있을 경우, 리더 선출을 실행시켜서 선호 리더를 현재 리더로 만들어준다.

## 6.4 요청처리
### 처리 과정
 * 브로커는 연결 받는 각 포트별로 억섹터 스레드를 하나씩 실행시킨다.
 * 억섹터 스레드는 연결을 생성하고 들어온 요청을 프로세서 스레드에 넘긴다.
 * 프로세서 스레드는 요청을 받아 요청 큐에 넣는다. 혹은 응답 큐에서 응답을 꺼내서 클라이언트에 보낸다.
   * 가끔은 클라이언트로 보낼 응답에 지연이 필요할 때가 있다.
   * 지연된 응답들은 완료될 때까지 퍼거토리에 저장된다. 
 * I/O 스레드는 요청 큐의 요청을 하나씩 꺼내서 실제 처리한 후 응답 큐에 넣는다.


### 쓰기 요청


### 읽기 요청
 * 클라이언트의 요청이 오면 유효성 검사부터 한다. - 지정된 오프셋이 해당 파티션에 존재하는지)
 * 제로카피 최적화 : 파일에서 일겅온 메시지들을 중간 버퍼를 거치지 않고 바로 네트워크 채널로 보낸다. (대부분의 DB들과의 차이점)
    * 오버헤드가 사라지며 성능이 향상된다.
 * 클라이언트는 모든 인-싱크 레플리카에 쓰여진 메시지들만 읽을 수 있다.
    * 크래시 상황이 발생하면 메시지의 일관성이 결여될 수 있기 때문이다.
    * 브로커 사이 복제가 너무 늦어지는 상황을 대비하기 위해 replica.lag.time.max.ms 설정으로 지연을 제한한다.
    * 이 시간 이상 지나면 아웃오브싱크 레플리카가 된다.

### 기타 요청
 * 예전엔 클라이언트가 오프셋을 기록하기 위해 주키퍼 사용했지만 지금은 오프셋 저장용 카프카 토픽을 사용한다.
 * 클라이언트가 업데이트를 하기 전에 브로커들을 먼저 업그레이드 하길 권장하는 이유
    * 새 브로커는 예전 요청을 처리할 수 있지만, 그 반대는 아니다. 





