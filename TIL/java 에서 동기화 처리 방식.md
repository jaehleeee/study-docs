# java 에서 동기화 처리 방식

## 블로킹 동기화 (w/ synchronized)
 * 모니터 매커니즘을 활용한다.
 * `배타 동기 큐 -> 임계 영역 -> 조건 동기 큐` 로 구성
 * 여기서 임계영역은 스레드가 락을 들고 들어가는 오직 하나의 스레드 작업 영역
 * 베타동기 큐는 synchronized 이며, 임계 영역이 비어지면 임계 영역으로 보낸다.
 * wait(): 임계영역에서 조건 동기 큐로 이동,
 * notify(), notifyAll(): 조건 동기 큐에서 임계 영역(비어있을때)으로 이동
 * 단점은 하나의 스레드만 임계영역에 들어갈 수 있기 때문에 성능 이슈가 있다. + 데드락 문제도 발생 가능하다.

## 논블로킹 동기화
 * 다른 스레드의 작업 여부와 상관없이 자신의 작업을 수행
 * Atomic 타입이 대표적
 * 하나의 자원에 여러 스레드가 접근할 때 매커니즘으로 CAS 알고리즘 + Volatile
   * CAS으로 원자성 보장
   * Volatile으로 가시성 보장

### CAS 알고리즘 (Compare And Set)
 * 수정 직전 시점 저장해둔 자원의 값과 수정 직후 시점 자원의 값을 비교한다.
   * 같이 같으면 (즉, 연산하는 동안 다른 스레드의 접근 & 수정이 없었다면) -> 연산된 값으로 update 후 true 반환
   * 값이 다르면, 수정하지 않고 false 반환
     * (false 반환 후 동작은 개발자 요구사항에 따라 달라진다)
     * exception 날릴 수도 있고, true 일때까지 일정 횟수 반복할 수도 있고

### volatile 이란?
 * 변수의 값을 메인 메모리에 저장하고, 각 스레드가 해당 변수의 최신 값을 읽고 쓸 수 있도록 보장
 * 이를 통해 변수의 값이 스레드 로컬 캐시에 저장되지 않도록 하고, 여러 스레드가 동시에 변수에 접근하더라도 항상 최신 값
 *  volatile 변수는 모든 스레드가 항상 메인 메모리에서 읽고 쓰도록 강제되어 가시성 문제를 해결합니다.
 * volatile 자체는 원자성을 보장하진 않는다.

### Atomic 타입에 대하여
 * Atomic 내부엔 volatile 필드 변수가 있고 여기에 value를 저장한다.
 * volatile 변수는 jvm 메모리에서 쓰레드로 값을 가져와 연산을 진행한다.
   * 연산을 진행할때 CAS 가 진행된다. (메모리에 있던 값과 쓰레드에 있는 값을 비교)
