# 18. 상속보다는 컴포지션을 사용하라
## 핵심 정리
 * 패키지 경계를 넘어 다른 패키지 구체 클래스를 상속하는 일은 위험하다
   * 상위 클래스에서 제공하던 메서드가 변경되거나 새로운 메서드가 생길 수 있으니...
   * 컴포지션을 활용하라
#### 컴포지션
 * **새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조**
    * 상속하려 했던 메서드가 모두 제공되어야 한다면, 상속하려 했던 클래스의 조상 인터페이스를 구현해서 강제 override를 통해 제공하라.
 * 컴포지션한 클래스가 변경되거나 새로운 메서드가 생겨도 영향 받지 않는다.

#### 컴포지션 예시
 * 원하는 타입의 Set을 주입받을 수 있다
 * 전형적인 데코레이터 패턴
```
public class ForwardingSet<E> implements Set<E> {
  private final Set<E> s;
  public  ForwardingSet(Set<E>S) { this.s = s;}

  public void clear() {s.clear();}
  public boolean contains(Object o) {return s.contins(o);}
  ....

}
```

## 완벽 공략
#### 데코레이터 패턴
 * 기존 코드를 변경하지 않고 부가 기능 추가

![image](https://github.com/jaehleeee/study-docs/assets/48814463/3443e0d0-8f59-4bf3-a85e-d1fa8504e3aa)

#### 콜백 프레임워크와 셀프 문제
 * 다른 함수(A)의 인자로 전달된 함수(B)를 의미. A 함수 내부에서 필요한 시점에 호출될 수 있는 함수를 의미힌다.
 * 래퍼로 감싸고 있는 내부 객체가 어떤 함수(A)의 콜백(B)으로 사용되는 경우 this 전달한다면, 해당 클래스(A)는 래퍼가 아닌 내부 객체를 호출 한다.
 * (어떻게 보면 되게 당연한 결과... ㅋ , 잘 이해안되면 좀 더 찾아볼 것)
