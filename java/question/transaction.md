# 트랜잭션에 대해서
 * 데이터베이스는 트랜잭션을 통해 데이터 완전성을 지원한다.


## 쿼리 실행 프로세스
1. 쿼리를 실행하면 쿼리처리기로 들어온다.
2. 쿼리처리기는 쿼리 처리에 필요한 데이터를 먼저 `데이터 캐시`에서 조회한다.
    * 없다면 `데이터 파일`에서 데이터를 조회한다. 
3. 필요한 데이터를 가지고, `로그 캐시`로 간다. 로그 캐시에 필요한 데이터가 없다면 `로그 파일`에서 가져온다.
4. 로그에는 `ReDo 로그`와 `UnDo 로그`가 있다.
    *  `ReDo 로그` 는 쿼리 실행을 통해 수정된 내용을 로그로 저장해두고 쿼리가 정상 완료되면 커밋한다.
    *  `UnDo 로그` 는 쿼리 실행 중 실패가 발생하면 이전으로 롤백하기 위해 기존 데이터를 저장해둔 로그다.
5. 로그에서 발생한 변경 혹은 롤백 사항을 데이터 캐시에 저장한다.


## RDB  4가지 속성 : ACID
1. Atomicity 원자성 : 쿼리의 일부만 실행되거나 실패해선 안되고, 전체가 성공하거나 실패해야한다.
2. Consistency 일관성 : 데이터베이스의 컬럼 등의 속성이 일관되게 유지되어야 한다.
3. Durability 지속성 : 성공적으로 커밋된 데이터는 영속성을 지닌다.
4. Isolation 독립성 : 트랜잭션 작업 중엔 다른 트랜잭션이 끼어들 수 없이 독립적으로 수행되어야 한다.


## 스프링
 * 스프링에서는 PlatformtransactionManager를 통해 다양한 데이터소스에 맞게 트랜잭션을 사용할 수 있도록 제공.

### 스프링 트랜잭션의 속성
#### propagation : 트랜잭션 전파
 * 진행중인 트랜잭션이 있는 와중에 새로운 트랜잭션이 발생했을때 어떻게 동작할지를 결정함.
 * REQUIRED : (디폴트) 기존 트랜잭션이 있다면 합류, 없다면 새로 트랜잭션 생성
 * SUPPORTS : 기존 트랜잭션이 있다면 합류, 없다면 트랜잭션 없이 메서드 실행
 * MANDATORY : 기존 트랜잭션이 있다면 합류, 없다면 예외 발생
 * REQUIRES_NEW : 기존 트랜잭션이 있다면 보류하고 새로운 트랜잭션을 만든다.  없다면 새로 트랜잭션 생성
 * NOT_SUPPORTED : 트랜잭션을 아예 없이 메서드 실행하는 설정. 기존 트랜잭션이 있다면 보류하고 트랜잭션 없이 메서드 실행
 * NEVER : 트랜잭션을 사용하지 않도록 강제. 기존 트랜잭션이 있다면 예외 발생
 * NESTED : 기존 트랜잭션이 있다면 합류함. 단, 내부로 들어간 신규 트랜잭션의 커밋/롤백은 기존에 있던 트랜잭션에 영향을 미치지 않는다. 반대로 기존 트랜잭션의 커밋/롤백에는 중첩된 트랜잭션은 영향을 받는다.

#### Isolation : 트랜잭션 격리 수준
 * 동시에 여러 트랜잭션이 진행될때, 트랜잭션 진행 수준을 다른 트랜잭션에 공개할지 여부를 결정.
 * DEFAULT : 디폴트는 DB의 설정을 따름. 보통 READ_COMMITTED를 많이 사용.
 * READ_UNCOMMMITTED : 가장 낮은 격리 수준. 커밋되지 않은 데이터를 모두 공개함.
 * READ_COMMITTED : 가장 많이 사용됨. 커밋된 데이터만 공개. 다만 다른 트랜잭션이 읽은 데이터가 또 다시 수정된 경우 문제가 발생할 수 있다.
 * REPEATABLE_READ : 누군가 읽은 트랜잭션 데이터는 다른 트랜잭션이 수정할 수 없다. 다만, 트랜잭션 중 새로운 row가 추가된 것에 대해서는 제한이 없으므로 문제가 발생할 수 있다. 
 * SERIALIZABLE : 가장 강력한 격리. 동시 같은 테이블의 정보에 접근할 수 없다. 성능이 매우 떨어짐.


### 참고
 * https://www.youtube.com/watch?v=aX9c7z9l_u8
