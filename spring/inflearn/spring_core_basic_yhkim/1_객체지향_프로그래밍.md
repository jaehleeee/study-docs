# 객체지향 프로그래밍

## 다형성 : 객체지향의 꽃
### 자동차라는 역할
 * 역할 : 자동차
 * 역할을 구현 : K3, 아반떼
 * 차종이 바뀐다고 해서 운전 방법이 바뀌지 않는다.
 * 운전자는 자동차의 내부 구조를 알 필요가 없고, 운전법만 알면 된다.
### 뮤지컬 공연의 역할.
 * 로미오라는 역할, 줄리엣이라는 역할.
 * 그 역할을 구현 : 배우
 * 그 역할을 하는 배우는 누구든 할 수 있어야 한다.
### 역할과 구현을 분리
 * 클라이언트는 인터페이스만 알면 되고, 내부 구조는 몰라도 된다.
 * 클라이언트는 내부 구조가 변경되어도 영향을 받지 않는다.
 * 클라이언트는 구현이 변경되어도 영향 받지 않는다.
 * 클라이언트란? 요청하는 주체.
### java 세계에서는?
 * 역할 : interface
 * 구현 : 클래스, 구현 객체
 * 객체를 설계할 때는 역할과 구현을 명확히 분리해야 한다.
 * 간단히 정의하면 오버로딩(overloading)은 새로운 메소드를 정의하는 것입니다.
 * 하지만 오버라이딩(overriding)은 상속받은 기존의 메소드를 재정의하는 것입니다.
### 다형성의 본질
 * 인터페이스를 구현한 객체 인스턴스를 실행시점에 유연하게 변경 가능하다는 점.
 * 클라이언트는 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.
### 역할과 구현의 한계
 * 인터페이스 자체 변경이 필요하다면, 큰 변경이 발생한다. (로미오 역할 대사가 변경되면, 그 역할을 연습하는 배우들 모두의 변경이 필요해진다.)
 * 인터페이스 설계가 가장 중요하다.


## 스프링과 객체지향
 * 스프링은 다형성을 극대화해서 이용할 수 있게 해준다.
 * `제어의 역전`, `의존 관계 주입`은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.


## 좋은 객체 지향 설계의 5가지 원칙 (SOLID)
### SRP 단일 책임 원칙
 * 한 클래스는 하나의 책임만 가져야 한다.
 * 책임이란? 모호하다. 변경이 있을때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것.
### OCP 개방-폐쇄 원칙
 * 확장엔 열려있고, 변경에는 닫혀있어야 한다.
 * 다형성 활용하면 가능.
    * 그냥 다형성만 만들면 안되고, 클래스 연관관게를 맺어주는 별도의 조립, 설정자가 필요하다. (Spring Container의 역할.)
### LSP 리스코프 치환 원칙
 * 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
 * 자동차 인터페이스는 악셀을 밟으면 앞으로 가야한다. 뒤로 가게되면 LSP 위반.
 * 기능 보장을 의미한다.
### ISP 인터페이스 분리 원칙
 * 특정 클라이언트를 위한 인터페이스에 대해 범용성 인터페이스 하나보다는, 여러 인터페이스가 더 낫다.
 * 자동차 인터페이스보다, 운전 인터페이스와 정비 인터페이스로 분리하는게 좋다.
 * 인터페이스가 명확해지고, 대체 가능성이 높아진다.
### DIP 의존관계 역전 원칙
 * 구현 클래스에 의존하지 말고, 인터페이스, 즉 역할에 의존해야한다.
 * 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.
 * 운전자는 특정 차량(K3)에만 의존적이되면, 차량 변경이 힘들어진다. 자동차의 역할에만 의존해야한다.


#### 여기서 의존이란?
 * 알면 의존이다..!
 * MemberService는 MemoryMemberRepository, JdbcMemberRepository 모두 안다. 그러니 두 repository에 의존한다.
 * MemberService가 아래처럼 직접 구현 클래스를 선택한다면 DIP 위반이다.
```
public class MemberService {

   // private memberRepository memberRepository = new MemoryMemberRepository();
   private memberRepository memberRepository = new JdbcMemberRepository();

   ...

}
```



